(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{598:function(t,a,s){"use strict";s.r(a);var r=s(31),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[s("big",[t._v("作者：chenglNG(yuanchenglang)")])],1),t._v(" "),s("p",[s("big",[t._v("日期：2021年2月10号")])],1),t._v(" "),s("h1",{attrs:{id:"源计划"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#源计划"}},[t._v("#")]),t._v(" 源计划")]),t._v(" "),s("h2",{attrs:{id:"javascript"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[t._v("#")]),t._v(" javascript")]),t._v(" "),s("h3",{attrs:{id:"基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),s("h3",{attrs:{id:"谈谈你对原型链的理解？-✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对原型链的理解？-✨"}},[t._v("#")]),t._v(" 谈谈你对原型链的理解？ ✨")]),t._v(" "),s("p",[t._v("原型是一个对象或者类实例的一个数据共享区。访问对象或者类实例的属性或方法时，先查找自身的属性或方法，如果找不到，继续查找原型。例如函数的portotype就是原型属性。")]),t._v(" "),s("p",[t._v("原型中保存着着另一个原型的引用，另一个原型又保存着另一个原型的引用，像这样的引用关系就叫做原型链。访问对象或者类实例的属性或方法时，先查找自身的属性或方法，如果找不到，继续查找原型，如果还找不到，继续查找下一个原型，直到结束，如果还找不到，返回undefind。对象或类实例通过继承实方式现原型链，能够复用父类对象，实例中的属性和方法。\n我们还可以 通过hasOwnProperty判断属性是否在原型上，true表示不在。")]),t._v(" "),s("h3",{attrs:{id:"如何判断是否是数组？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何判断是否是数组？"}},[t._v("#")]),t._v(" 如何判断是否是数组？")]),t._v(" "),s("p",[t._v("Array.isArray、instance of Array")]),t._v(" "),s("h3",{attrs:{id:"es6模块与commonjs模块有什么区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6模块与commonjs模块有什么区别？"}},[t._v("#")]),t._v(" ES6模块与CommonJS模块有什么区别？")]),t._v(" "),s("p",[t._v("同步和异步是在于程序中的各个任务是否按顺序执行，异步操作可以改变程序的正常执行顺序。\n"),s("br"),t._v("\n阻塞和非阻塞就是发起调度，会不会挂起当前线程，停止执行代码，直到调度完才继续执行代码。")]),t._v(" "),s("br"),t._v("\n异步加载：不按代码执行顺序加载。\n"),s("br"),t._v("\n同步加载：按照代码的执行顺序加载，什么时候执行代码发起调度就什么时候调度。\n"),s("h4",{attrs:{id:"amd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#amd"}},[t._v("#")]),t._v(" AMD:")]),t._v(" "),s("p",[t._v("异步加载模块，不阻塞html等其他资源的加载（不阻塞线程），回调函数遵循时间循环（不一定按顺序执行）")]),t._v(" "),s("h4",{attrs:{id:"commonjs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[t._v("#")]),t._v(" CommonJS")]),t._v(" "),s("p",[t._v("1.单例模式\n2.同步加载，按顺序执行代码，同时会阻塞当前代码执行（挂起当前线程）\n3. 当有导入的时候（import或require）,都会暂停当前模块执行的代码，并产生一些奇妙的效果。（export fn,函数声明）（node环境）")]),t._v(" "),s("h4",{attrs:{id:"es6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[t._v("#")]),t._v(" es6:")]),t._v(" "),s("p",[t._v("1.单例模式\n2.异步加载（挂起当前线程，先加载执行，之后再执行当前代码），不按顺序执行代码（异步），会挂起当前线程（阻塞）\n3.当有导入的时候（import或require）,都会暂停当前模块执行的代码，并产生一些奇妙的效果。（export fn,函数声明）（浏览器环境）\n4. 不能重新赋值")]),t._v(" "),s("h4",{attrs:{id:"相同："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#相同："}},[t._v("#")]),t._v(" 相同：")]),t._v(" "),s("p",[t._v("都是单例模式，创建过的实例会被缓存。\n当有导入的时候（import或require）,都会暂停当前模块执行的代码，并产生一些奇妙的效果。（export fn,函数声明）")]),t._v(" "),s("h4",{attrs:{id:"不同："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不同："}},[t._v("#")]),t._v(" 不同：")]),t._v(" "),s("p",[t._v("CommonJS先require同步加载（require时才加载执行，有一定的阻塞,更适合服务器，读取文件无需请求下载)，ES6异步加载（先加载执行完所有模块，再来执行当前代码（当前代码的函数声明会比加载模块靠前完成），适合浏览器）\ncommonJS使用的module.exports导出（对象是浅拷贝），es6采用export default等语法导出，导出的对象是直接引用。\nes6 导出的对象不能重新赋值（会报错），commonjs不会.")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("聊⼀聊如何在JavaScript中实现不可变对象？")])]),t._v(" "),s("li",[s("p",[t._v("JavaScript的参数是按照什么⽅式传递的？")])]),t._v(" "),s("li",[s("p",[t._v("js有哪些类型?\nnumber,string,null,undefind,boolean")])]),t._v(" "),s("li",[s("p",[t._v("为什么会有BigInt的提案？")])]),t._v(" "),s("li",[s("p",[t._v("null与undefined的区别是什么？\nnull 表示 空值")])])]),t._v(" "),s("p",[t._v("undefind表示 不是空值，表示值不存在")]),t._v(" "),s("h3",{attrs:{id:"_0-1-0-2为什么不等于0-3？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-0-2为什么不等于0-3？"}},[t._v("#")]),t._v(" 0.1+0.2为什么不等于0.3？")]),t._v(" "),s("p",[t._v("首先，计算时要将小数的10进制转换为标准机器读懂的编码，在这个过程中，因为位数原因，造成精度会顺损失，导致计算出的结果大于0.3")]),t._v(" "),s("h3",{attrs:{id:"类型转换的规则有哪些？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型转换的规则有哪些？"}},[t._v("#")]),t._v(" 类型转换的规则有哪些？")]),t._v(" "),s("p",[t._v("if语句，while,==，数学运算符")]),t._v(" "),s("h3",{attrs:{id:"类型转换的原理是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型转换的原理是什么？"}},[t._v("#")]),t._v(" 类型转换的原理是什么？")]),t._v(" "),s("p",[t._v('当遇到转换规则时，则在内部代码会判断 值类型，好比如[] + 1,先调用valueOf()方法，发现类型不是原始值类型，接着再调用toString(),最后[]得到 ""转换，相当于""+1,结果为"1"')]),t._v(" "),s("h3",{attrs:{id:"js机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js机制"}},[t._v("#")]),t._v(" js机制")]),t._v(" "),s("h3",{attrs:{id:"解释下变量提升？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解释下变量提升？✨"}},[t._v("#")]),t._v(" 解释下变量提升？✨")]),t._v(" "),s("p",[t._v("javascript代码在真正执行前会根据词法环境注册var、let、const声明的变量及声明函数。首先会进行函数的声明，给对应的标识符进行函数绑定，若标识符已存在，则覆盖之前的值。然后进行变量的声明。 若该变量（标识符）没注册过，则默认等于undefind。若声明了变量或函数，并在声明变量或函数语句前执行console.log打印变量，如果是变量则打印undefind，如果是函数则打印函数体。但let，const会报错，因为console.log处于暂时性死区。")]),t._v(" "),s("h3",{attrs:{id:"⼀段javascript代码是如何执⾏的？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⼀段javascript代码是如何执⾏的？✨"}},[t._v("#")]),t._v(" ⼀段JavaScript代码是如何执⾏的？✨")]),t._v(" "),s("p",[t._v("javascript是逐行执行的，执行的时候，首先会创建一个全局执行上下文，执行上下文里有词法环境，函数上下文等执行所需的变量，当遇到一个执行函数时，引擎会停止当前执行上下文的执行，创建一个函数执行上下文，并，压入执行栈，执行栈是用来管理跟踪当前执行上下文的位置，保存着全局执行上下文和所有的函数执行上下文，当函数执行完毕时，函数执行上下文弹出执行栈，相关的作用域等数据也随之回收，继续执行全局执行上下文。当前执行全局代码相当于执行宏任务，如果遇到宏任务，则把宏任务放到宏任务队列，等待下一次时间循环，如果是微任务，则放到微任务队列，等待在下一次宏任务执行前全部执行完毕。")]),t._v(" "),s("h3",{attrs:{id:"javascript的作⽤域链理解吗？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript的作⽤域链理解吗？✨"}},[t._v("#")]),t._v(" JavaScript的作⽤域链理解吗？✨")]),t._v(" "),s("p",[t._v("作用域就是在函数执行上下文中用于查找变量或函数。作用域又称词法环境，当函数执行时，就会生成，用于跟踪函数中声明的变量和函数。let、const声明的变量保存在块级作用域，var声明的变量放在名为local作用域。作用作用域有可能引用着父级作用域。")]),t._v(" "),s("h3",{attrs:{id:"谈⼀谈你对this的了解？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈⼀谈你对this的了解？✨"}},[t._v("#")]),t._v(" 谈⼀谈你对this的了解？✨")]),t._v(" "),s("p",[t._v("this指的函数上下文，和函数执行上下文不是一个东西。this相当于一个动态的作用域，函数中，this可以是指向一个对象或全局对象window，或者undefind。通过call，bind，apply可以修改函数this的指向，严格模式下，this为undefind，在箭头函数中，this指向箭头函数所在执行上下文的函数上下文。")]),t._v(" "),s("h3",{attrs:{id:"箭头函数的this指向哪⾥？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数的this指向哪⾥？✨"}},[t._v("#")]),t._v(" 箭头函数的this指向哪⾥？✨")]),t._v(" "),s("p",[t._v("this指向箭头函数所在执行上下文的函数上下文")]),t._v(" "),s("h3",{attrs:{id:"理解闭包吗？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#理解闭包吗？✨"}},[t._v("#")]),t._v(" 理解闭包吗？✨")]),t._v(" "),s("p",[t._v("闭包就是作用域的特殊应用（个人感觉差别不大）。在外部函数内声明内部函数时，闭包就创建了。闭包保存着内部函数所需要变量或函数（内部函数作用域没有的），并存在于作用域链上。只要有函数引用着闭包就不会消失（可能会引起内存泄漏问题），请不要多度使用闭包，或者清空无用的函数。（let fn = null）")]),t._v(" "),s("h3",{attrs:{id:"实现bind和call两个方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现bind和call两个方法"}},[t._v("#")]),t._v(" 实现bind和call两个方法")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("\nFunction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("portotype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("call")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("content"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    content"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fn "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" content"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    content"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fn "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nFunction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("portotype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("apply")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("content "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" window"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" args "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    content"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fn "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" content"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    content"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fn "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nFunction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("portotype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("bind")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("content "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" window"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("local")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          content "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("content"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("concat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("local"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        content"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fn "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    fn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("portotype "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("portotype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" fn\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),s("h3",{attrs:{id:"js内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js内存"}},[t._v("#")]),t._v(" js内存")]),t._v(" "),s("h3",{attrs:{id:"讲讲javascript垃圾回收是怎么做的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#讲讲javascript垃圾回收是怎么做的？"}},[t._v("#")]),t._v(" 讲讲JavaScript垃圾回收是怎么做的？")]),t._v(" "),s("p",[t._v("js对象 种类分为分新生代和老生代，新生代分配的攻坚比老生代小很多，新生代主要存储着很快不用的对象，老生代存储着长期存活的对象（window等），新生代的对象在多次回收中都没被回收，会晋升为老生代。变量那些数据会随着 执行上下文的销毁被回收。回收垃圾前，会对对象进行标记，从根对象往下遍历并标记，能遍历的为可达，不能遍历为不可达，之后会回收不可达的对象。")]),t._v(" "),s("h3",{attrs:{id:"javascript的基本类型和复杂类型是储存在哪⾥的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript的基本类型和复杂类型是储存在哪⾥的？"}},[t._v("#")]),t._v(" JavaScript的基本类型和复杂类型是储存在哪⾥的？")]),t._v(" "),s("p",[t._v("基本类型存储在栈内存里面，复杂类型存储在堆内存")]),t._v(" "),s("h3",{attrs:{id:"异步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步"}},[t._v("#")]),t._v(" 异步")]),t._v(" "),s("h3",{attrs:{id:"async-await-是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-await-是什么？"}},[t._v("#")]),t._v(" async/await 是什么？")]),t._v(" "),s("p",[t._v("async/await 是 promise的语法糖，允许 一组 promise 对象 按照一定顺序执行。")]),t._v(" "),s("ol",[s("li",[t._v("async声明一个异步函数")]),t._v(" "),s("li",[t._v("异步函数默认返回promise对象")]),t._v(" "),s("li",[t._v("异步函数内部执行到await时，会暂停当前执行上下文执行，直到promise 有返回结果")]),t._v(" "),s("li",[t._v("await 只能在异步函数使用")]),t._v(" "),s("li",[t._v("异步函数中所有的promise执行完成后，异步函数返回的promise对象才会执行then方法")])]),t._v(" "),s("p",[t._v("与promise的优势：\n解决回调地狱，以同步方式编写代码，代码更加优雅\n方便调试")]),t._v(" "),s("h3",{attrs:{id:"dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dom"}},[t._v("#")]),t._v(" dom")]),t._v(" "),s("ul",[s("li",[t._v("DOM的事件模型是什么？\n脚本模型，内联模型，动态绑定")])]),t._v(" "),s("div",{staticClass:"language-html extra-class"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!--⾏内绑定：脚本模型--\x3e")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("button")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("onclick")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("javascrpt:alert("),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("Hello"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v(")"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("Hello1"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("button")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!--内联模型--\x3e")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("button")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("onclick")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("showHello()"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("Hello2"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("button")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!--动态绑定--\x3e")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("button")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("id")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("btn3"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("Hello3"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("button")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),s("ul",[s("li",[t._v("DOM的事件流是什么？\n事件流又称为事件传播，指发生 行为交互时触发相应事件，触发时按照一定顺序传递事件。事件传播分为三个阶段，捕获阶段，目标阶段，冒泡阶段。当事件发生时，先触发，捕获事件，再触发目标事件，最后再触发冒泡事件，一直往上冒泡。")]),t._v(" "),s("li",[t._v("什么是事件委托?\n在元素的最外部元素统一绑定事件，最外部元素内部的任何元素无需绑定事件，只要触发事件，事件就会冒泡到最外部元素，执行绑定的事件。")])]),t._v(" "),s("ol",[s("li",[t._v("好处\n减少内存占用")]),t._v(" "),s("li",[t._v("坏处\nfocus、blur 之类的事件本身没有事件冒泡机制，所以⽆法委托\nmousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗⾼，不适 合事件委托")])]),t._v(" "),s("h3",{attrs:{id:"bom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bom"}},[t._v("#")]),t._v(" bom")]),t._v(" "),s("h2",{attrs:{id:"css"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[t._v("#")]),t._v(" css")]),t._v(" "),s("h3",{attrs:{id:"基础-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础-2"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),s("h3",{attrs:{id:"css选择器的优先级是怎样的？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css选择器的优先级是怎样的？✨"}},[t._v("#")]),t._v(" CSS选择器的优先级是怎样的？✨")]),t._v(" "),s("p",[t._v("不同选择的优先级不一样。如果按优先级分类abcd,a包含行内样式（1），b包含id选择器，c包含类选择器，伪类和属性选择符个数（n）,d包含类型选择器和伪元素个数。abcd不同种类的选择器个数按照abcd顺序拼接，得到的值最大的，优先级最大")]),t._v(" "),s("ul",[s("li",[t._v("link和@import的区别？")])]),t._v(" "),s("p",[t._v("link：")]),t._v(" "),s("p",[t._v("import")]),t._v(" "),s("ol",[s("li",[t._v("增加请求数目\n（影响页面加载速率）")])]),t._v(" "),s("p",[t._v("建议会用link，尽量少用import")]),t._v(" "),s("h3",{attrs:{id:"有哪些⽅式（css）可以隐藏⻚⾯元素？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有哪些⽅式（css）可以隐藏⻚⾯元素？"}},[t._v("#")]),t._v(" 有哪些⽅式（CSS）可以隐藏⻚⾯元素？")]),t._v(" "),s("p",[t._v("display:none\nvisbility:hidden\nopacity: 0")]),t._v(" "),s("h3",{attrs:{id:"em-px-rem区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#em-px-rem区别？"}},[t._v("#")]),t._v(" em\\px\\rem区别？")]),t._v(" "),s("p",[t._v("他们都会字体大小的单位。\npx是一个基础的单位，描述字体显示的大小\nem 是基于父级元素字体大小来计算，如父元素字体为12px，子元素1em，那么子元素字体大小就是(12 x 1 )px\nrem 是基于html字体大小来计算,同理em")]),t._v(" "),s("h3",{attrs:{id:"块级元素⽔平居中的⽅法？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#块级元素⽔平居中的⽅法？"}},[t._v("#")]),t._v(" 块级元素⽔平居中的⽅法？")]),t._v(" "),s("div",{staticClass:"language-css extra-class"},[s("pre",{pre:!0,attrs:{class:"language-css"}},[s("code",[t._v(" "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("margin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 0 auto"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n //浮动\n position：absolute\n\n left：50% - 自身宽度一半\n\n // 弹性盒子\n 父元素 "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("display")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" flex\n 子元素 align-items：center\n\n")])])]),s("h3",{attrs:{id:"css有⼏种定位⽅式？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css有⼏种定位⽅式？"}},[t._v("#")]),t._v(" CSS有⼏种定位⽅式？")]),t._v(" "),s("p",[t._v("3种。")]),t._v(" "),s("ol",[s("li",[t._v("static默认的。")]),t._v(" "),s("li",[t._v("absolute。参考包含块（position为非static）定位（top,left）,r如果没有可参考的position包含块，就以html根元素作为包含块参考。不占用原来空间")]),t._v(" "),s("li",[t._v("relative。参考原来的位置做偏移，偏移后仍占据原来的空间")]),t._v(" "),s("li",[t._v("fixed 相对于浏览器窗口进行定位。")])]),t._v(" "),s("ul",[s("li",[t._v("如何理解z-index？✨\nz-index属性 控制 层叠上下文中层叠元素次序。\n层叠上下文中 不同元素 层叠顺序不一样。它们是按照这样的规则排序。z-index 为 负 positioned元素 > 非positioned block元素 > 非positioned float元素 >  非positioned inline元素 > positioned z-index为0或者auto的元素 > positioned (z-index > 1 )元素.z-index 控制 positioned元素离屏幕的距离（堆叠次序）")])]),t._v(" "),s("h3",{attrs:{id:"如何理解层叠上下⽂？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何理解层叠上下⽂？✨"}},[t._v("#")]),t._v(" 如何理解层叠上下⽂？✨")]),t._v(" "),s("p",[t._v("z-index 不为auto的定位元素会在 一定 空间按照 堆叠次序 排序（里屏幕的距离），这个空间就叫做层叠上下文。z-index不为auto的定位元素、opacity小于1 的元素、ransform 属性值不为 none的元素、perspective 值不为 none 的元素都会创建自己的层叠上下文，层叠上下文的堆叠次序，不会影响外部的堆叠次序。")]),t._v(" "),s("h3",{attrs:{id:"清除浮动有哪些⽅法？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#清除浮动有哪些⽅法？"}},[t._v("#")]),t._v(" 清除浮动有哪些⽅法？")]),t._v(" "),s("ol",[s("li",[t._v("给 父元素 添加伪元素")]),t._v(" "),s("li",[t._v("给父元素设置为BFC（块级格式化上下文），如：overflow 不是 visible元素、绝对定位元素、浮动元素、display为inline-block元素。")])]),t._v(" "),s("h3",{attrs:{id:"你对css-sprites的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#你对css-sprites的理解"}},[t._v("#")]),t._v(" 你对css-sprites的理解")]),t._v(" "),s("p",[t._v("css-sprite就是雪碧图，把许多图片整合到一张图，减少网页请求次数，提升网页加载速度，提高体验。以后有图标要扩展的时候，只需在一张图添加就可以了。很方便。")]),t._v(" "),s("ul",[s("li",[t._v("你对媒体查询的理解？")])]),t._v(" "),s("h3",{attrs:{id:"你对盒模型的理解？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#你对盒模型的理解？✨"}},[t._v("#")]),t._v(" 你对盒模型的理解？✨")]),t._v(" "),s("p",[t._v("页面中所有元素都看作是一个矩形盒子，这个盒子包含元素的内容，内边距(padding)，外边距（marign），边框(border)。我们通过css样式（浮动，定位，行内块）设置盒子的属性（宽高，边框）和布局。盒子有块级盒子，行内盒子（在行盒子里头）。常规块级盒子里有相邻外边距折叠（折叠发生在常规块级盒子，行内盒子，浮动元素，绝对定位盒子（absolute或fixed）不会发生外边距折叠）等特性，垂直外边距对行内盒子没影响等特性。当然可以通过border-sizing：border-box改变计算盒子的大小方式。")]),t._v(" "),s("ul",[s("li",[t._v("标准盒模型和怪异盒模型有什么区别？✨")])]),t._v(" "),s("h3",{attrs:{id:"谈谈对bfc-block-formatting-context-的理解？-✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈对bfc-block-formatting-context-的理解？-✨"}},[t._v("#")]),t._v(" 谈谈对BFC(Block Formatting Context)的理解？ ✨")]),t._v(" "),s("p",[t._v("BFC顾名思义就是块级格式化上下文。overflow不为auto的元素，浮动元素，绝对定位，display为inline-block之类的元素都可以自己创建内部的块级格式化上下文。BFC中，会有外边距重叠（相邻的外边距会重合，取最大值），会自动包含 浮动元素。块级盒子左边距默认和包含块左边距对齐。防止文字环绕浮动元素。防止相邻元素外边距重叠（但同一个bfc上下文会发生外边距折叠，只能防止不同bfc元素外边距折叠）")]),t._v(" "),s("h3",{attrs:{id:"为什么有时候⼈们⽤translate来改变位置⽽不是定位？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么有时候⼈们⽤translate来改变位置⽽不是定位？"}},[t._v("#")]),t._v(" 为什么有时候⼈们⽤translate来改变位置⽽不是定位？")]),t._v(" "),s("p",[t._v("translate性能比 定位性能要好。因为 定位会放生浏览器重绘和复合，translate只会发生复合；tranlate会创建一个GPU图层使用，定位元素却是用cpu，tranlate更高效。")]),t._v(" "),s("h3",{attrs:{id:"伪类和伪元素的区别是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#伪类和伪元素的区别是什么？"}},[t._v("#")]),t._v(" 伪类和伪元素的区别是什么？")]),t._v(" "),s("p",[t._v("伪类：如:focus,:link,:visited,:active,:hover,用于给元素在特定状态添加样式\n伪元素: 如:before,:after,:first-letter(第一行)。可以减少页面 元素的个数，无需添加额外的元素标签就可以给页面添加css效果")]),t._v(" "),s("h3",{attrs:{id:"你对flex的理解？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#你对flex的理解？✨"}},[t._v("#")]),t._v(" 你对flex的理解？✨")]),t._v(" "),s("p",[t._v("可用于设置水平方向的布局。解决行内块（留白问题），浮动（浮动元素不能随空间变化而变化），表格水平布局（不能应用外边距，不能排序）带来的一些问题。flex布局会忽略float和display属性（通常设置float和display用于向后兼容），少量代码可以简单实现水平布局。里面的非定位元素也可以通过z-index控制层叠次序（网格布局同理）\n不好的就是，刚打开页面时，元素开始计算（变大），造成页面跳动的，体验不好，通常给元素设置固定宽高，可以减少影响。")]),t._v(" "),s("h3",{attrs:{id:"关于css的动画与过渡问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于css的动画与过渡问题"}},[t._v("#")]),t._v(" 关于CSS的动画与过渡问题")]),t._v(" "),s("h2",{attrs:{id:"html"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html"}},[t._v("#")]),t._v(" html")]),t._v(" "),s("h3",{attrs:{id:"doctype-⽂档类型-的作⽤是什么？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#doctype-⽂档类型-的作⽤是什么？✨"}},[t._v("#")]),t._v(" doctype(⽂档类型) 的作⽤是什么？✨")]),t._v(" "),s("p",[t._v("声明浏览器解析类型，声明浏览器按照html5的标准解析 html和css内容。")]),t._v(" "),s("p",[t._v("浏览器浏览的类型有 怪异模式（不声明doctype，默认是这个模式），标准模式。\njs通过 window.document.compatMode可以知道 当前浏览器模式。\n怪异模式下，盒子的宽度是包括 边跨 + 内边距 + 实际内容，怪异盒子，还有一些css不被浏览器识别 ！important。")]),t._v(" "),s("p",[t._v("标准模式下，浏览器按照w3c标准解析文档，就算是跨浏览器也不会出现页面不一致问题。")]),t._v(" "),s("h3",{attrs:{id:"这三种模式的区别是什么？-接上⼀问追问"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#这三种模式的区别是什么？-接上⼀问追问"}},[t._v("#")]),t._v(" 这三种模式的区别是什么？(接上⼀问追问)")]),t._v(" "),s("p",[t._v("怪异模式下，盒子的宽度是包括 边跨 + 内边距 + 实际内容，怪异盒子，还有一些css不被浏览器识别 ！important。")]),t._v(" "),s("p",[t._v("标准模式下，浏览器按照w3c标准解析文档，就算是跨浏览器也不会出现页面不一致问题。")]),t._v(" "),s("p",[t._v("ie8有一介于两种模式之间的模式（基本淘汰）")]),t._v(" "),s("h3",{attrs:{id:"html、xml-和-xhtml-有什么区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html、xml-和-xhtml-有什么区别？"}},[t._v("#")]),t._v(" HTML、XML 和 XHTML 有什么区别？")]),t._v(" "),s("p",[t._v("HTML(超⽂本标记语⾔):就是我们平时所用到的html元素\nXML（可扩展标记语⾔）：是一种通用的数据传输 标准（不管是在什么地方），作用和json类似。\nXHTML（可扩展超⽂本标记语⾔)）：以前html4版本以前 标准比较混乱，所以XHTML是HTML的新规范（用xml规范html），通过开头doctype 声明。现在XHTML被淘汰了，现在是HTML5新一代的规范。")]),t._v(" "),s("h3",{attrs:{id:"什么是data-属性？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是data-属性？"}},[t._v("#")]),t._v(" 什么是data-属性？")]),t._v(" "),s("p",[t._v("html的数据属性，可以通过js操作dom的dataset属性获取数据（ie9）.有了前端框架，现在不流行了")]),t._v(" "),s("h3",{attrs:{id:"你对html语义化的理解？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#你对html语义化的理解？✨"}},[t._v("#")]),t._v(" 你对HTML语义化的理解？✨")]),t._v(" "),s("p",[t._v("使用恰当语气的表情，如文章就是用article。\n好处：\n更好的seo，提升搜索排名\n对开发者友好，标签知名达意，增强可读性，能够清晰看出网页结构，便于维护（避免div麻疹）\n能够让阅读器理解，帮助听力有障碍的人阅读")]),t._v(" "),s("h3",{attrs:{id:"html5与html4的不同之处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html5与html4的不同之处"}},[t._v("#")]),t._v(" HTML5与HTML4的不同之处")]),t._v(" "),s("ol",[s("li",[t._v("⽂件类型声明（<!DOCTYPE>）仅有⼀型：<!DOCTYPE HTML>。")]),t._v(" "),s("li",[t._v("新的解析顺序：不再基于SGML。")]),t._v(" "),s("li",[t._v("新的元素：section, video, progress, nav, meter, time, aside, canvas, command, datalist, details, embed, figcaption, figure, footer, header, hgroup, keygen, mark, output, rp, rt, ruby, source, summary, wbr。 input元素的新类型：date, email, url等等。")]),t._v(" "),s("li",[t._v("新的属性：ping（⽤于a与area）, charset（⽤于meta）, async（⽤于script）。")])]),t._v(" "),s("h3",{attrs:{id:"有哪些常⽤的meta标签？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有哪些常⽤的meta标签？"}},[t._v("#")]),t._v(" 有哪些常⽤的meta标签？")]),t._v(" "),s("div",{staticClass:"language-html extra-class"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[t._v("//设置移动端 显示\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("meta")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("viewport"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("content")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("width=device-width, initial-scale=1, maximum-scale=1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\ninitial-scale 初始显示的比例，1表示默认尺寸\nmaximum-scale 最大可放大的比例，1表示不能的放大\n//设置http缓存过期日期\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("meta")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("http-equiv")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("expires"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("content")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("Wed, 20 Jun 2019 22:33:00 GMT"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\n//设置文档格式\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("meta")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("charset")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("utf-8"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),s("h3",{attrs:{id:"src和href的区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#src和href的区别？"}},[t._v("#")]),t._v(" src和href的区别？")]),t._v(" "),s("p",[t._v("src指向的外部资源，通过src指定的资源地址，会请求下载外部资源，并（执行）应用到文档，如css，js\nhref是 指网络资源的地址，通常是连接标签元素和 其他文档，如果地址是指向文件，会现在文件。")]),t._v(" "),s("h3",{attrs:{id:"知道img的srcset的作⽤是什么？（追问）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#知道img的srcset的作⽤是什么？（追问）"}},[t._v("#")]),t._v(" 知道img的srcset的作⽤是什么？（追问）")]),t._v(" "),s("p",[t._v("srcset数属性是用来设置响应式图片。因为在手机端上或者分辨率很小的设备上，不需要很大的图片，这样会造成更多流量的使用（用户可能不愿意）和 很多的处理器处理时间和内存。srset属性设置一组图片的地址（逗号分隔），根据不同设备的分辨率下载对应的图片（这个和浏览器的算法有关）。如果不需要根据分辨率大小来切换图片，也可以设置sizes属性（媒体所声明的宽度）去选择图片（声明宽度 * 物理像素与css像素比 < srcset 声明的宽度描述值（400w））")]),t._v(" "),s("h3",{attrs:{id:"还有哪⼀个标签能起到跟srcset相似作⽤？（追问）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#还有哪⼀个标签能起到跟srcset相似作⽤？（追问）"}},[t._v("#")]),t._v(" 还有哪⼀个标签能起到跟srcset相似作⽤？（追问）")]),t._v(" "),s("p",[s("picture",[t._v(".一个picture可以包含多个source，如果浏览器匹配到合适的source，就让source要显示的内容在img上显示，如果浏览器不支持该语法和没有匹配到，则img标签的src作为兜底属性。")])]),t._v(" "),s("h3",{attrs:{id:"script标签中defer和async的区别？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#script标签中defer和async的区别？✨"}},[t._v("#")]),t._v(" script标签中defer和async的区别？✨")]),t._v(" "),s("p",[t._v("他们都是script便签上的属性，都是让js文件进行异步加载。defer规定脚本在dom解析完后按照下载顺序执行。async先下载完先执行（有先后依赖关系的情况，并不适⽤），可能会阻塞html解析，也有可能导致获取不到没解析的dom元素。")]),t._v(" "),s("h3",{attrs:{id:"有⼏种前端储存的⽅式，这些⽅式的区别是什么？✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有⼏种前端储存的⽅式，这些⽅式的区别是什么？✨"}},[t._v("#")]),t._v(" 有⼏种前端储存的⽅式，这些⽅式的区别是什么？✨")]),t._v(" "),s("p",[t._v("localStorage，sessionStorage， cookie，indexDB，Web SQL")]),t._v(" "),s("ul",[s("li",[t._v("localStorage可以存储 5m大的数据，不手动清除，是不会随着浏览器推出而清除。")]),t._v(" "),s("li",[t._v("sessionStorag同样是5m的数据，浏览器tab退出时就会清除数据，有相关事件，不能在同源窗口公用，会话级别存储。")]),t._v(" "),s("li",[t._v("cookie，通常只能存储4kb的数据，通常不会存放敏感的数据，会自动随着请求头带到服务器，")]),t._v(" "),s("li",[t._v("indexDB，是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快 速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常⽅便")]),t._v(" "),s("li",[t._v("Web SQL 2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实 现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换， 较为繁琐。")])]),t._v(" "),s("h2",{attrs:{id:"http"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" http")]),t._v(" "),s("h3",{attrs:{id:"http有哪些⽅法？这些⽅法的具体作⽤是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http有哪些⽅法？这些⽅法的具体作⽤是什么？"}},[t._v("#")]),t._v(" HTTP有哪些⽅法？这些⽅法的具体作⽤是什么？")]),t._v(" "),s("ol",[s("li",[t._v("GET")])]),t._v(" "),s("ul",[s("li",[t._v("无请求体")]),t._v(" "),s("li",[t._v("有响应体")]),t._v(" "),s("li",[t._v("安全（不会修改服务器状态）")]),t._v(" "),s("li",[t._v("冥等（发请求多次的过也是等于一次的效果）")]),t._v(" "),s("li",[t._v("缓存")]),t._v(" "),s("li",[t._v("可用于表单提交")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("POST（增删查改，但不是标准，增加一条数据不要用patch）")])]),t._v(" "),s("ul",[s("li",[t._v("有请求体")]),t._v(" "),s("li",[t._v("有响应体")]),t._v(" "),s("li",[t._v("不是幂等，多次调用多次请求，多次改变服务器状态（如增加一条数据）")]),t._v(" "),s("li",[t._v("不安全（会改变服务器状态）")]),t._v(" "),s("li",[t._v("可用于表单提交")]),t._v(" "),s("li",[t._v("有效缓存（仅当包含新鲜度信息时）")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("PUT（对已知的资源进行替换；替换资源）")])]),t._v(" "),s("ul",[s("li",[t._v("有请求体")]),t._v(" "),s("li",[t._v("没有响应体")]),t._v(" "),s("li",[t._v("冥等")]),t._v(" "),s("li",[t._v("不安全")]),t._v(" "),s("li",[t._v("不缓存")]),t._v(" "),s("li",[t._v("不可用于表单提交")])]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[t._v("OPTION （预检测）")]),t._v(" "),s("li",[t._v("DELETE （删除资源）")])]),t._v(" "),s("ul",[s("li",[t._v("没请求体")]),t._v(" "),s("li",[t._v("没响应体")]),t._v(" "),s("li",[t._v("冥等（多次删除同一id的数据，会返回404）")]),t._v(" "),s("li",[t._v("不能等用于 表单")]),t._v(" "),s("li",[t._v("不能缓存")]),t._v(" "),s("li",[t._v("不安全")])]),t._v(" "),s("ol",{attrs:{start:"6"}},[s("li",[t._v("CONNECT（建立隧道，发送tcp流）")]),t._v(" "),s("li",[t._v("TRACER（用于调试才测试）")]),t._v(" "),s("li",[t._v("PATCH（对已知资源进⾏局部更新、修改）")])]),t._v(" "),s("ul",[s("li",[t._v("有请求体")]),t._v(" "),s("li",[t._v("有响应体")]),t._v(" "),s("li",[t._v("多次请求多次调用")]),t._v(" "),s("li",[t._v("不安全")]),t._v(" "),s("li",[t._v("不缓存")]),t._v(" "),s("li",[t._v("不可用于表单提交")])]),t._v(" "),s("ol",{attrs:{start:"9"}},[s("li",[t._v("HEAD（用于获取一个文件大小 再来判断是否需要下载）")])]),t._v(" "),s("ul",[s("li",[t._v("没有请求头")]),t._v(" "),s("li",[t._v("没有响应头")]),t._v(" "),s("li",[t._v("不可用于表单提交")]),t._v(" "),s("li",[t._v("安全")]),t._v(" "),s("li",[t._v("冥等")]),t._v(" "),s("li",[t._v("没缓存")])]),t._v(" "),s("h3",{attrs:{id:"get和post有什么区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get和post有什么区别？"}},[t._v("#")]),t._v(" GET和POST有什么区别？")]),t._v(" "),s("ul",[s("li",[t._v("get表示获取资源，psot表示 修改资源（类似的有patch）")]),t._v(" "),s("li",[t._v("get会被缓存。 post不会")]),t._v(" "),s("li",[t._v("get没有请求体。post有")]),t._v(" "),s("li",[t._v("get安全，post不安全")]),t._v(" "),s("li",[t._v("get是冥等，psot不是")])]),t._v(" "),s("h3",{attrs:{id:"put和post都是给服务器发送新增资源，有什么区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#put和post都是给服务器发送新增资源，有什么区别？"}},[t._v("#")]),t._v(" PUT和POST都是给服务器发送新增资源，有什么区别？")]),t._v(" "),s("ul",[s("li",[t._v("PUT幂等性，post没有")]),t._v(" "),s("li",[t._v("put没有响应体（返回的数据），post有")]),t._v(" "),s("li",[t._v("put不能用于表单提交，post可以")]),t._v(" "),s("li",[t._v("tips:put和psot本身都可以用来创建资源")])]),t._v(" "),s("h3",{attrs:{id:"put和patch都是给服务器发送修改资源，有什么区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#put和patch都是给服务器发送修改资源，有什么区别？"}},[t._v("#")]),t._v(" PUT和PATCH都是给服务器发送修改资源，有什么区别？")]),t._v(" "),s("p",[t._v("PUT的用意是直接（覆盖）替换资源，Patch只是修改已知服务器资源\nput 冥等，patch不是冥等")]),t._v(" "),s("h3",{attrs:{id:"post和patch都是给服务器发送修改资源，有什么区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#post和patch都是给服务器发送修改资源，有什么区别？"}},[t._v("#")]),t._v(" POST和PATCH都是给服务器发送修改资源，有什么区别？")]),t._v(" "),s("p",[t._v("post可以用于创建资源，patch旨在对已知资源进行修改")]),t._v(" "),s("h3",{attrs:{id:"http的请求报⽂是什么样的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http的请求报⽂是什么样的？"}},[t._v("#")]),t._v(" http的请求报⽂是什么样的？")]),t._v(" "),s("ul",[s("li",[t._v("请求行\n描述请求方法，http协议版本， URL字段")]),t._v(" "),s("li",[t._v("请求头部\n有一些属性，content-type，host，user-agent")]),t._v(" "),s("li",[t._v("请求体（put,post用在存放要运输的数据）")])]),t._v(" "),s("h3",{attrs:{id:"聊⼀聊http的部⾸有哪些？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#聊⼀聊http的部⾸有哪些？"}},[t._v("#")]),t._v(" 聊⼀聊HTTP的部⾸有哪些？")]),t._v(" "),s("ol",[s("li",[t._v("通用：\n实体⾸部字段（Entiy Header Fields）:针对请求报⽂和响应报⽂的实体部分使⽤⾸部")])]),t._v(" "),s("ul",[s("li",[t._v("Allow 资源可⽀持http请求的⽅法 ✨")]),t._v(" "),s("li",[t._v("Content-Language 实体的资源语⾔")]),t._v(" "),s("li",[t._v("Content-Encoding 实体的编码格式")]),t._v(" "),s("li",[t._v("Content-Length 实体的⼤⼩（字节）")]),t._v(" "),s("li",[t._v("Content-Type 实体媒体类型 38")]),t._v(" "),s("li",[t._v("HTTP⾯试题 Content-MD5 实体报⽂的摘要 Content-Location 代替资源的yri Content-Rnages 实体主体的位置返回 Last-Modified 资源最后的修改资源 ✨ Expires 实体主体的过期资源 ✨\n一般字段")]),t._v(" "),s("li",[t._v("Cache-Control 控制缓存 ✨")]),t._v(" "),s("li",[t._v("Connection 连接管理、逐条⾸部 ✨")]),t._v(" "),s("li",[t._v("Upgrade 升级为其他协议")]),t._v(" "),s("li",[t._v("via 代理服务器的相关信息")]),t._v(" "),s("li",[t._v("Wraning 错误和警告通知")]),t._v(" "),s("li",[t._v("Transfor-Encoding 报⽂主体的传输编码格式 ✨")]),t._v(" "),s("li",[t._v("Trailer 报⽂末端的⾸部⼀览")]),t._v(" "),s("li",[t._v("Pragma 报⽂指令 Date 创建报⽂的⽇期")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("请求头")])]),t._v(" "),s("ul",[s("li",[t._v("Accept 客户端或者代理能够处理的媒体类型 ✨")]),t._v(" "),s("li",[t._v("Accept-Encoding 优先可处理的编码格式")]),t._v(" "),s("li",[t._v("Accept-Language 优先可处理的⾃然语⾔")]),t._v(" "),s("li",[t._v("Accept-Charset 优先可以处理的字符集")]),t._v(" "),s("li",[t._v("If-Match ⽐较实体标记（ETage） ✨")]),t._v(" "),s("li",[t._v("If-None-Match ⽐较实体标记（ETage）与 If-Match相反 ✨")]),t._v(" "),s("li",[t._v("If-Modified-Since ⽐较资源更新时间（Last-Modified）✨")]),t._v(" "),s("li",[t._v("If-Unmodified-Since⽐较资源更新时间（Last-Modified），与 If-Modified-Since相反 ✨")]),t._v(" "),s("li",[t._v("If-Rnages 资源未更新时发送实体byte的范围请求")]),t._v(" "),s("li",[t._v("Range 实体的字节范围请求 ✨")]),t._v(" "),s("li",[t._v("Authorization web的认证信息 ✨")]),t._v(" "),s("li",[t._v("Proxy-Authorization 代理服务器要求web认证信息")]),t._v(" "),s("li",[t._v("Host 请求资源所在服务器 ✨")]),t._v(" "),s("li",[t._v("From ⽤户的邮箱地址")]),t._v(" "),s("li",[t._v("User-Agent 客户端程序信息 ✨")]),t._v(" "),s("li",[t._v("Max-Forwrads 最⼤的逐跳次数")]),t._v(" "),s("li",[t._v("TE 传输编码的优先级")]),t._v(" "),s("li",[t._v("Referer 请求原始放的url")]),t._v(" "),s("li",[t._v("Expect 期待服务器的特定⾏为")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("响应头")])]),t._v(" "),s("ul",[s("li",[t._v("Accept-Ranges 能接受的字节范围")]),t._v(" "),s("li",[t._v("Age 推算资源创建经过时间")]),t._v(" "),s("li",[t._v("Location 令客户端重定向的URI ✨")]),t._v(" "),s("li",[t._v("vary 代理服务器的缓存信息")]),t._v(" "),s("li",[t._v("ETag 能够表示资源唯⼀资源的字符串 ✨")]),t._v(" "),s("li",[t._v("WWW-Authenticate 服务器要求客户端的验证信息")]),t._v(" "),s("li",[t._v("Proxy-Authenticate 代理服务器要求客户端的验证信息")]),t._v(" "),s("li",[t._v("Server 服务器的信息 ✨")]),t._v(" "),s("li",[t._v("Retry-After 和状态码503 ⼀起使⽤的⾸部字段，表示下次请求服务器的时间")])]),t._v(" "),s("h3",{attrs:{id:"聊⼀聊http的状态码有哪些？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#聊⼀聊http的状态码有哪些？"}},[t._v("#")]),t._v(" 聊⼀聊HTTP的状态码有哪些？")]),t._v(" "),s("ol",[s("li",[t._v("2xx成功")])]),t._v(" "),s("ul",[s("li",[t._v("200请求成功")]),t._v(" "),s("li",[t._v("202 Accepted 请求已接受，但是还没执⾏，不保证完成请求")]),t._v(" "),s("li",[t._v("204 响应体没有数据")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("3xx重定向")])]),t._v(" "),s("ul",[s("li",[t._v("301 永久性重定向")]),t._v(" "),s("li",[t._v("302 found，临时性重定向，表示资源临时被分配了新的 URL ✨")]),t._v(" "),s("li",[t._v("303 see other，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法丁⾹获取资源")]),t._v(" "),s("li",[t._v("304 not modified，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况")]),t._v(" "),s("li",[t._v("307 temporary redirect，临时重定向，和302含义相同")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("4xx客户端错误")])]),t._v(" "),s("ul",[s("li",[t._v("400 bad request，请求报⽂存在语法错误 ✨")]),t._v(" "),s("li",[t._v("401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息")]),t._v(" "),s("li",[t._v("403 orbidden，表示对请求资源的访问被服务器拒绝 ✨")]),t._v(" "),s("li",[t._v("404 notfound,没找到资源")])]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[t._v("5xx服务端错误")])]),t._v(" "),s("ul",[s("li",[t._v("500， 服务器在执行请求时发生错误")]),t._v(" "),s("li",[t._v("501 Not Implemented 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，或者请求是服务 器不⽀持的某个⽅法")]),t._v(" "),s("li",[t._v("503 service unavailable，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求")]),t._v(" "),s("li",[t._v("505 http version not supported 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本")])]),t._v(" "),s("h3",{attrs:{id:"http的keep-alive是⼲什么的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http的keep-alive是⼲什么的？"}},[t._v("#")]),t._v(" HTTP的keep-alive是⼲什么的？")]),t._v(" "),s("p",[t._v("每次创建连接的时候都要耗费资源和时间（tcp三次握手），为了解决这样的问题，可以重用连接，不关闭连接，下次发送请求时继续使用这个连接。在请求头设置connection: keep-alive")]),t._v(" "),s("h3",{attrs:{id:"为什么有了http为什么还要https？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么有了http为什么还要https？"}},[t._v("#")]),t._v(" 为什么有了HTTP为什么还要HTTPS？")]),t._v(" "),s("p",[t._v("https是安全版的http，因为http协议的数据都是明⽂进⾏传输的，所以对于⼀些敏感信息的传输就很不安全，HTTPS就\n是为了解决HTTP的不安全⽽⽣的。")]),t._v(" "),s("h3",{attrs:{id:"https是如何保证安全的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https是如何保证安全的？"}},[t._v("#")]),t._v(" HTTPS是如何保证安全的？")]),t._v(" "),s("ul",[s("li",[t._v("对称加密就是用一个密钥 来进行数据加密解密")]),t._v(" "),s("li",[t._v("非对称加密就是用公钥来加密，对应的私钥解密，私钥加密，对应的公钥才能解密。")]),t._v(" "),s("li",[t._v("https协议是结合非对称解密和对称加密来进行通信的。先用非对称加密来传输密钥，然后双方再用密钥进行文明的加密和密文的解密。\n如果只是用对称加密，那么密钥有可能被中间人盗取，信息会泄密，那么客户端和服务端都需要传递各自的公钥，双方再结合自己的私钥、公钥还有其他数据（随机数，服务器信息），通过ECDHE算法计算通信所用的会话密钥（双方计算的密钥是一样的）。那么公钥也可能是中间人伪造的（中间人代替客户端发送公钥），那么就需要属于自己（服务器或客户端）CA的签名证书去验证公钥，但是签名证书（其中一端的通过私钥生成CSR和ca的证书和私钥生成的，就是将证书内容通过HASH算法生成一个摘要，再用私钥进行加密）的真伪性同样也需要验证，需要CA的证书和公钥去验证（用私钥解密的内容得到摘要，在进行对比验证真伪性，正确的话，用得到的摘要用公钥解密，对比服务名称，ip地址等，如果没问题，则证明公钥是正确的。），一般知名机构的CA的证书都会放在浏览器，自动完成验证，否则需要企业自己去验证。")])]),t._v(" "),s("p",[t._v("如果使用非对称加密，每次传送数据就非常慢，经过很多繁琐的验证步骤。")]),t._v(" "),s("h3",{attrs:{id:"但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。"}},[t._v("#")]),t._v(" 但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。")]),t._v(" "),s("h3",{attrs:{id:"http2相对于http1-x有什么优势和特点？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http2相对于http1-x有什么优势和特点？"}},[t._v("#")]),t._v(" HTTP2相对于HTTP1.x有什么优势和特点？")]),t._v(" "),s("ul",[s("li",[t._v("二进制分层帧。\n帧就是http2数据的最小单位，每一帧都有一个streamID.\n二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧，二进制更容易被解析")]),t._v(" "),s("li",[t._v("多路复用\n同一个域，一次tcp连接可用于多个请求，可以不断地像服务端发送帧，然后服务器根据每一帧的sreamID拼接一整块数据。http1.x协议多个请求多个tcp连接，而且同一个域最多可有4个tcp连接的建立。http2相比HTTP1，能节省更多的资源和时间。")]),t._v(" "),s("li",[t._v("头部压缩")]),t._v(" "),s("li",[t._v("服务端推送\n浏览器发一个请求，服务器可以主动向浏览器推送和这个请求相关的资源，不用浏览器发起后续请求。")])]),t._v(" "),s("h3",{attrs:{id:"http的缓存的过程是怎样的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http的缓存的过程是怎样的？"}},[t._v("#")]),t._v(" HTTP的缓存的过程是怎样的？")]),t._v(" "),s("ul",[s("li",[t._v("客户端发起资源请求")]),t._v(" "),s("li",[t._v("服务器返回资源，并标记该资源是否缓存")]),t._v(" "),s("li",[t._v("如果缓存，客户端就缓存")]),t._v(" "),s("li",[t._v("下次客户端发起请求相同资源时，先去服务端验证资源的有效期，")]),t._v(" "),s("li",[t._v("如果有效，则直接应用缓存，无效则服务器返回最新资源")])]),t._v(" "),s("h3",{attrs:{id:"什么时候会触发强缓存或者协商缓存？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么时候会触发强缓存或者协商缓存？"}},[t._v("#")]),t._v(" 什么时候会触发强缓存或者协商缓存？")]),t._v(" "),s("h4",{attrs:{id:"强缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),s("ul",[s("li",[s("h2",{attrs:{id:"expires"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v("\nWed, 11 May 2018 07:20:00 GMT\n"),s("ul",[s("li",[t._v("介绍\n它描述的是⼀个绝对时间，由服务器返回。如果修改了本地时间，会有影响。")])])]),t._v(" "),s("li",[t._v("cache-control\n-格式：\nmax-age=315360000\n-介绍\n描述是一个相对时间。优先级比 expires高，目前主流是使用这种方式。")]),t._v(" "),s("li",[t._v("还有其他值表示\n"),s("ul",[s("li",[t._v("cache-contol: no-cache.先缓存本地，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使⽤")]),t._v(" "),s("li",[t._v("Cache-Control: no-store，不会产⽣任何缓存")]),t._v(" "),s("li",[t._v("Cache-Control: public可以被所有⽤户缓存，包括终端和CDN等中间代理服务器")]),t._v(" "),s("li",[t._v("Cache-Control: private只能被终端浏览器缓存，不允许中继缓存服务器进⾏缓存")])])])]),t._v(" "),s("h4",{attrs:{id:"协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),s("p",[t._v("当cache-control或expires过期，cache-control为no-cache，就去和服务器协商，看看缓存和服务器资源版本是否一致，一致返回304，不一致就返回新的资源")]),t._v(" "),s("h3",{attrs:{id:"服务器判断缓存是否是新鲜的⽅法就是依靠http的另外两组信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务器判断缓存是否是新鲜的⽅法就是依靠http的另外两组信息"}},[t._v("#")]),t._v(" 服务器判断缓存是否是新鲜的⽅法就是依靠HTTP的另外两组信息")]),t._v(" "),s("ul",[s("li",[t._v("last-Modify-Since/if-Modify-Since\n服务端返回 last-Modify-Since的时间，当资源过期了，再发起一个请求时就会与服务器协商，根据请求中的if-Modify-Since的值（last-Modify-Since的时间）判断资源是否最新")]),t._v(" "),s("li",[t._v("Etag/If-None-match\nEtag存放内容摘要，当资源过期了，再发起一个请求时就会与服务器协商，根据请求中的If-None-match值判断资源是否最新。精度比last-Modify-Since/if-Modify-Since高")])]),t._v(" "),s("h3",{attrs:{id:"http的整个流程，涉及tcp-ip协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http的整个流程，涉及tcp-ip协议"}},[t._v("#")]),t._v(" http的整个流程，涉及tcp/ip协议")]),t._v(" "),s("h3",{attrs:{id:"tcp粘包是怎么回事，如何处理-✨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp粘包是怎么回事，如何处理-✨"}},[t._v("#")]),t._v(" TCP粘包是怎么回事，如何处理? ✨")]),t._v(" "),s("p",[t._v("发送数据包时，服务器会启用延迟发送算法，短时间内，可能会会缓冲几个数据包，然后发送的时候，可能会有一个或多个包。主要是节省网络资源的目的\n解决：. 多次发送之前间隔⼀个等待时间；关闭算法；数据分包（在数据上做标记，在分开组合完整的数据），")]),t._v(" "),s("h3",{attrs:{id:"为什么udp不会分包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么udp不会分包"}},[t._v("#")]),t._v(" 为什么udp不会分包")]),t._v(" "),s("ol",[s("li",[t._v("TCP协议是⾯向流的协议，UDP是⾯向消息的协议")]),t._v(" "),s("li",[t._v("UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据")]),t._v(" "),s("li",[t._v("UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易 进⾏区分处理了。")])]),t._v(" "),s("h3",{attrs:{id:"ios7层模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ios7层模型"}},[t._v("#")]),t._v(" IOS7层模型")]),t._v(" "),s("p",[t._v("应用层 > 表示层 > 会话层 > 传输层 > 网络层 > 链路层 > 物理层")]),t._v(" "),s("h3",{attrs:{id:"讲⼀下三次握⼿？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#讲⼀下三次握⼿？"}},[t._v("#")]),t._v(" 讲⼀下三次握⼿？")]),t._v(" "),s("p",[t._v("客户端 向服务器 发起 请求，申请简历连接，这是第一次握手。\n服务端收到请求，同意连接，然后返回确认的信号，这是第二次握手。\n客户端收到服务端回应后，确认可以建立连接，然后建立tcp连接了，这是第三次握手。")]),t._v(" "),s("h3",{attrs:{id:"讲⼀下四次握⼿？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#讲⼀下四次握⼿？"}},[t._v("#")]),t._v(" 讲⼀下四次握⼿？")]),t._v(" "),s("p",[t._v("客户端想关闭连接，向服务器发起了申请（1）\n服务端收到后，接受客户端关闭连接，但还准备好关闭连接。（2）\n服务端准备好关闭后，告诉客户端，我可以了（3）\n客户端收到服务端 回应，然后对服务器说，你关闭吧。之后服务器关闭了，客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊ CLOSED 状态。（4）")]),t._v(" "),s("h2",{attrs:{id:"浏览器原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理"}},[t._v("#")]),t._v(" 浏览器原理")]),t._v(" "),s("ul",[s("li",[t._v("点击关注本公众号获取⽂档最新更新,并可以领取配套于本指南的 《前端⾯试⼿册》 以及最标准的简历模板.")]),t._v(" "),s("li",[t._v("常⻅的浏览器内核有哪些?")]),t._v(" "),s("li",[t._v("浏览器的主要组成部分是什么？")]),t._v(" "),s("li",[t._v("浏览器是如何渲染UI的？")]),t._v(" "),s("li",[t._v("浏览器如何解析css选择器？")]),t._v(" "),s("li",[t._v("DOM Tree是如何构建的？")]),t._v(" "),s("li",[t._v("浏览器重绘与重排的区别？")]),t._v(" "),s("li",[t._v("如何触发重排和重绘？")]),t._v(" "),s("li",[t._v("如何避免重绘或者重排？")]),t._v(" "),s("li",[t._v("前端如何实现即时通讯？")]),t._v(" "),s("li",[t._v("什么是浏览器同源策略？")]),t._v(" "),s("li",[t._v("如何实现跨域？\n"),s("a",{attrs:{href:"http://taligarsiel.com/Projects/howbrowserswork1.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://taligarsiel.com/Projects/howbrowserswork1.html"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"算法基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法基础"}},[t._v("#")]),t._v(" 算法基础")]),t._v(" "),s("ul",[s("li",[t._v("选择排序")]),t._v(" "),s("li",[t._v("插入排序")]),t._v(" "),s("li",[t._v("希尔排序")]),t._v(" "),s("li",[t._v("归并排序")]),t._v(" "),s("li",[t._v("快速排序")]),t._v(" "),s("li",[t._v("二分查找")])]),t._v(" "),s("h2",{attrs:{id:"网络安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络安全"}},[t._v("#")]),t._v(" 网络安全")]),t._v(" "),s("ul",[s("li",[t._v("有哪些可能引起前端安全的的问题?")]),t._v(" "),s("li",[t._v("XSS分为哪⼏类?")]),t._v(" "),s("li",[t._v("如何预防XSS?")]),t._v(" "),s("li",[t._v("针对第⼀个要素：我们是否能够在⽤户输⼊的过程，过滤掉⽤户输⼊的恶意代码呢？")]),t._v(" "),s("li",[t._v("在⽤户提交时，由前端过滤输⼊，然后提交到后端。这样做是否可⾏呢？")]),t._v(" "),s("li",[t._v("那么，换⼀个过滤时机：后端在写⼊数据库前，对输⼊进⾏过滤，然后把“安全的”内容，返回给前端。这样是否可⾏")]),t._v(" "),s("li",[t._v("呢？")]),t._v(" "),s("li",[t._v("如何应对⽹络劫持?")]),t._v(" "),s("li",[t._v("HTTPS⼀定是安全的吗?")])]),t._v(" "),s("h2",{attrs:{id:"webpack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[t._v("#")]),t._v(" webpack")]),t._v(" "),s("ul",[s("li",[t._v("webpack与grunt、gulp的不同？")]),t._v(" "),s("li",[t._v("有哪些常⻅的Loader？")]),t._v(" "),s("li",[t._v("有哪些常⻅的Plugin？")]),t._v(" "),s("li",[t._v("Loader和Plugin的不同？")]),t._v(" "),s("li",[t._v("webpack的构建流程是什么?")]),t._v(" "),s("li",[t._v("是否写过Loader和Plugin？描述⼀下编写loader或plugin的思")]),t._v(" "),s("li",[t._v("路？")]),t._v(" "),s("li",[t._v("webpack的热更新是如何做到的？说明其原理？")]),t._v(" "),s("li",[t._v("如何⽤webpack来优化前端性能？")]),t._v(" "),s("li",[t._v("如何提⾼webpack的打包速度?")]),t._v(" "),s("li",[t._v("如何提⾼webpack的构建速度？")]),t._v(" "),s("li",[t._v("怎么配置单⻚应⽤？怎么配置多⻚应⽤？")])]),t._v(" "),s("h2",{attrs:{id:"vue"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),s("ul",[s("li",[t._v("你对MVVM的理解?")]),t._v(" "),s("li",[t._v("MVVM是什么?")]),t._v(" "),s("li",[t._v("MVVM的优缺点?")]),t._v(" "),s("li",[t._v("你对Vue⽣命周期的理解？")]),t._v(" "),s("li",[t._v("异步请求适合在哪个⽣命周期调⽤？")]),t._v(" "),s("li",[t._v("Vue组件如何通信？")]),t._v(" "),s("li",[t._v("computed和watch有什么区别?")]),t._v(" "),s("li",[t._v("Proxy与Object.defineProperty的优劣对⽐?")]),t._v(" "),s("li",[t._v("既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟")]),t._v(" "),s("li",[t._v("DOM进⾏diff检测差异?")]),t._v(" "),s("li",[t._v("Vue为什么没有类似于React中shouldComponentUpdate的⽣")]),t._v(" "),s("li",[t._v("命周期？")]),t._v(" "),s("li",[t._v("Vue中的key到底有什么⽤？")])]),t._v(" "),s("h2",{attrs:{id:"react"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),s("ul",[s("li",[t._v("React最新的⽣命周期是怎样的?")]),t._v(" "),s("li",[t._v("React的请求应该放在哪个⽣命周期中?")]),t._v(" "),s("li",[t._v("setState到底是异步还是同步?")]),t._v(" "),s("li",[t._v("React组件通信如何实现?")]),t._v(" "),s("li",[t._v("React有哪些优化性能是⼿段?")]),t._v(" "),s("li",[t._v("React如何进⾏组件/逻辑复⽤?")]),t._v(" "),s("li",[t._v("mixin、hoc、render props、react-hooks的优劣如何？")]),t._v(" "),s("li",[t._v("你是如何理解fiber的?")]),t._v(" "),s("li",[t._v("你对 Time Slice的理解?")]),t._v(" "),s("li",[t._v("redux的⼯作流程?")]),t._v(" "),s("li",[t._v("react-redux是如何⼯作的?")]),t._v(" "),s("li",[t._v("redux与mobx的区别?")]),t._v(" "),s("li",[t._v("redux中如何进⾏异步操作?")]),t._v(" "),s("li",[t._v("redux异步中间件之间的优劣?")])])])}),[],!1,null,null,null);a.default=e.exports}}]);