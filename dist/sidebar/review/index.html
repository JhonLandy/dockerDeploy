<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>源计划 | 香飘飘糯米之家</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <link rel="manifest" href="/manifest.json">
    <meta name="description" content="每天一杯糯米茶">
    
    <link rel="preload" href="/assets/js/runtime.60910846.js" as="script"><link rel="preload" href="/assets/css/1.styles.e4c6f4b0.css" as="style"><link rel="preload" href="/assets/js/chunk-elementUI.e4c6f4b0.js" as="script"><link rel="preload" href="/assets/css/4.styles.3bf4261c.css" as="style"><link rel="preload" href="/assets/css/2.styles.bd30ccf7.css" as="style"><link rel="preload" href="/assets/js/chunk-libs.bd30ccf7.js" as="script"><link rel="preload" href="/assets/js/app.d85d545c.js" as="script"><link rel="preload" href="/assets/css/5.styles.dc5d0932.css" as="style"><link rel="preload" href="/assets/js/5.dc5d0932.js" as="script"><link rel="preload" href="/assets/css/6.styles.194557f9.css" as="style"><link rel="preload" href="/assets/js/6.194557f9.js" as="script"><link rel="preload" href="/assets/js/54.3e9b0ec2.js" as="script"><link rel="preload" href="/assets/css/8.styles.d3f9f724.css" as="style"><link rel="preload" href="/assets/js/8.d3f9f724.js" as="script">
    <link rel="stylesheet" href="/assets/css/1.styles.e4c6f4b0.css"><link rel="stylesheet" href="/assets/css/4.styles.3bf4261c.css"><link rel="stylesheet" href="/assets/css/2.styles.bd30ccf7.css"><link rel="stylesheet" href="/assets/css/5.styles.dc5d0932.css"><link rel="stylesheet" href="/assets/css/6.styles.194557f9.css"><link rel="stylesheet" href="/assets/css/8.styles.d3f9f724.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-46e9af19><header class="navbar" data-v-46e9af19><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="data:image/png;base64,UklGRgwJAABXRUJQVlA4WAoAAAAQAAAAxwAAxwAAQUxQSOkFAAABb6C2kaQ2+Jl3kHmIiICq8dbvq3sxwvey7YsjaNt2dEe7ksBcrg1Zulxy+VhDLteGXK4NWbu04XJvyOVjgcu9YdwLMi6ZwOUeaEtSkf2v+Z1Vv1/VzLVmEf2fAP3f//8F/5LbXvBvYASlx0v30csKM4coy+vfb3/5K+bHX5PLDKpFSaCR1l6SPjXhXTlcAhwUZQ2ttBEhK+H6wHGGV3zpHx8uyDxII9z1wCSttwIqYb73trRfvNVJgjR9Hua3KaNM3QRgL8gAqtb1UCnIn4BmlqnVXuAeBjmHljWHSNJFkLoHwCQL1o9hWO5wFGQOB1YCTUk/DDHdzvZDh7rXJQnHZXUZBkngyFpBS5Ie9HpsXFP23xlNr2/BM6Qeh0HmMLQ20HRS/wCUFfTc2PNacCjpPvaCzCC2gEamEaCwF8a+TxdqkhbUgpzDxGgDO5nOgHKYE6Pl81mGkrpQCnICU6ML1NV+ePxPgOmYzI+9INPIiHxOuVLSjEMF/R1g9IGqRgSeZOoaJZ8ZFakHLwwzAkrOACjrIhRbWZQAQ/kkbKu9IC6FuR6oOD8EtjULVsnU2zApB7kZrlTYAVB1RoAKond/fFsBnncrxOVAnwXqzu9gUpisGea4z1fgHrDjnEDsN9kU53fOOxS6AzSccxhaZbl/ALblXhSivYS3bgW7BGiuoTmDI2kOE5kjQOaoEOq//2nKEWitobGAA2nmDLg7bbD5RlFyXmfZS5lBNWUF5SeCBBrODJopC2ikALUngguoOr+DekoCUcq6CNMi9FafltNefVNGrBOopMyZbOVGEVxH5gyG0iMfkk6M3g+eqeuBUqjfOaXiNK1zOJRpuX1A9nfvuDP7oxtncsed48zXlMN0gH2rDw11Hv162g/Hl0pLDqwfUszY7wGyTmvSe98qXUA1ZQlbuuTNshcFoe7TI/uxzAVEzkTaQE0Z10Vp+ow8sJJwFLXlc+JTNmZQ0chImJYfB7s+Ix+Z3Uc+KSeWeo9erqyborR8eh5Dy+zDvryXRdnx0QOZJtVMWlHzOy9KycvtbGBf/p3XyL/zSDHeqbBraKT0Hxn7X3vVpSne87RIRcyUELYepk96nFt//Wmju77OIfBumHkGorzmUHF+B1WpHeogSJ+scV5LiJwZNHPYCzLPRJTTGhoraCygJSlUK0Sf7HFOm5QEXippHqgeIvEgygeIUvYldb5/lf03YDIeX3vVVVdd9RYFHOAb57bjLOBAmU+AmnJMvIjy6AB1Zw6H2WaAchzgH+fRBWrODIbZlhDnkWSZWkQ59ICqcw6/zbaBwxwG2A8Akz9ZcQ59oOKcQZzps8BuDon1rpHTXhtE4T4LlJ0TmEjq3j42N8BkbN91qdcAc7pt6HorDjcASilTSQvCVn0S69mylBhEwa4HtpzfAVKHwHseA8xjpfWtONgIkDMyeqGGHolVzaALgyjU72BqXA9saxBqkm2AeaAs3Y0R5/ZDoFSQxCpn0h8MokAnMDEGQLkYA8yXKNslKyMOdAqx0QcqxnBbM5iWOgkM3//+B7wSY7LtoYFBFOYcjo0eUDVa0g9hKJ3CrnTJxmOAuSMfzY04zAyGRheoGQ1pYJxAS1LikRhH8usZRKGOjA5QL8IAsxpAF0YcZAGHxiXAThESY18h2huHKEQCB4aAqAAD3GkpiO414hBL2Lc20ChAYrxYYbRyiAKs4KXWGpr5DXCPFeqzRhxgDS1rBa38FkYtmOYOdb9NhmUROriHCtc19vyAppXAbm59o5yD/ugMgzSsBewV40rl0V4Dx0Eiaw77ubWByXYuuh44CrJjzYqgBOrKR3No+K2hap3BS/MbjN8uv9ijtx5u+S2YyPoh7OTnf32AsP3xpSm67Rrps0X7YUFMy+0XbVCkZYbe4+G4KIlfFw6lETTy6gPD4nWASNKKhtSFiqQ5DIP1gIOizKFuaQ1lSf1PSNJ3LpWkM3hpMG1gtyjXM91O+ROfkXeXaTncBVSKou8+XelvUMBOSeE7D1+q//v/P/kDAFZQOCD8AgAAUBwAnQEqyADIAD6RRphJpaQiISoYKWCwEglnbuFuXgD+ADRukBgnr7fxnNp2vRnt1OeL9LX+n35zduMnc8AfwD8APr97/Avee1N3M2IDSDCufohw7gYQN2pu5mXqbr0jYTL1dGjtRnL+a0h255wMHAJbMbk1uCq4N3zGfv9mrLqOWErkyvy9M88kZLVJzBIBZwZlRkOAnSlS/nZkIPE+nw2gvbdrjgs1Glnz8CHgBxKXzOGijmCXK06uzr+enIlSkiLync3e4U/mG2URpAizdR12O6vXoDSDCufohw7gYQN2pu5mxAaQYVzkAAD8x99ksx75MRJUkAAAAAVPdGa2IaaO3//nju47lQ8kJSR2T570HoUiBVBnIgfTkPnAYzfQphG5gos87k9DivIQWK/kaMoMWd4qzsJ/JID8lDaUUIcoQSTK8zupWE+pHPa/ricdpzUzfghCuyl//lgJs93/0DlQoz0P9giYdTm1V3gHaVJ/LBlx9Pi9jGCWxGgfuQx4HVtBHGvkBR8VE7wJIZ6yqURivHYGQctjcX75o2p0DWZS9oR3hPMUa6qajiQj8zKrIZgfl5pwZbwYf2BmaHYv5jhOCvGWgeCscTG/HkgnlW9c6Wyb88bUKJqLH//niaErQvCbE7H0iTD9jyFkNU980pCy7Kyo7aYGeFIUu5ex/bRY/NQXpbx+PVtoKX/DHSnSwa7Zo3L0XsFq3OY0KwisWScJ3/G7MU3+jlHvGUCTnLir29834x0v6IaPzKJcTBwdIwluLGXdn4oswdUD9kE7G+x95YHcT2fIvBf0kZ55Gat5u+eARW+/kFZprtLs2qHM53BHp6FFx5ZXx3IAUdnOr3kbQY1+63Eowc6Wzlflv9YWbiWI3RuVaLkM+AqVz1cOh1zgFdzqcwnBM7l1oHR79crQmWlPl8E9M5sGAH4vix1o/eWs6MYJjYeaTjGh50KkjlYHLZO9je9aZjXytkf7Uv/88OStsWZhEOTkS3PjdcMQAAAFymAAAAAAAAA=" alt="香飘飘糯米之家" class="logo"> <span class="site-name can-hide"></span></a> <nav class="nav-links can-hide"><div class="nav-item"><a href="/index.html" class="nav-link"><span class="nav-link">首页</span></a></div><div class="nav-item"><div class="dropdown-wrapper el-dropdown"><span class="el-dropdown-link"><span class="nav-link"> 前端 </span> <i class="el-icon-arrow-down el-icon--right"></i></span> <ul class="el-dropdown-menu el-popper" style="display:none;"><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> Javascript </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/web/javascript/ES6/index.html" class="nav-link-new"><span class="nav-link-new">ES6</span></a></li><li><a href="/nav/web/javascript/object/index.html" class="nav-link-new"><span class="nav-link-new">对象、类面向对象编程</span></a></li><li><a href="/nav/web/javascript/promise/index.html" class="nav-link-new"><span class="nav-link-new">期约与异步函数</span></a></li><li><a href="/nav/web/javascript/canvas/index.html" class="nav-link-new"><span class="nav-link-new">动画与Canvas图形</span></a></li><li><a href="/nav/web/javascript/form/index.html" class="nav-link-new"><span class="nav-link-new">表单脚本</span></a></li><li><a href="/nav/web/javascript/网络请求与远程资源.html" class="nav-link-new"><span class="nav-link-new">网络请求与远程资源</span></a></li><li><a href="/nav/web/javascript/工作者线程.html" class="nav-link-new"><span class="nav-link-new">工作者线程</span></a></li></ul></div></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/web/typescript/index.html" class="nav-link-new"><span class="nav-link-new">Typescript</span></a></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> Css </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/web/css/layout/index.html" class="nav-link-new"><span class="nav-link-new">布局</span></a></li><li><a href="/nav/web/css/animation/index.html" class="nav-link-new"><span class="nav-link-new">动画</span></a></li></ul></div></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> Vue </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/web/vue/api/index.html" class="nav-link-new"><span class="nav-link-new">基本使用</span></a></li></ul></div></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper el-dropdown"><span class="el-dropdown-link"><span class="nav-link"> 部署 </span> <i class="el-icon-arrow-down el-icon--right"></i></span> <ul class="el-dropdown-menu el-popper" style="display:none;"><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> docker </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/deployment/docker/base/index.html" class="nav-link-new"><span class="nav-link-new">基本命令</span></a></li></ul></div></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> Git </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/deployment/git/command/index.html" class="nav-link-new"><span class="nav-link-new">常用命令</span></a></li><li><a href="/nav/deployment/git/standard/index.html" class="nav-link-new"><span class="nav-link-new">提交规范</span></a></li><li><a href="/nav/deployment/git/ssh/index.html" class="nav-link-new"><span class="nav-link-new">SSH</span></a></li></ul></div></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/deployment/CICD/index.html" class="nav-link-new"><span class="nav-link-new">CI/CD</span></a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper el-dropdown"><span class="el-dropdown-link"><span class="nav-link"> 算法与数据结构 </span> <i class="el-icon-arrow-down el-icon--right"></i></span> <ul class="el-dropdown-menu el-popper" style="display:none;"><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> 排序 </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/code/sort/选择排序.html" class="nav-link-new"><span class="nav-link-new">选择排序</span></a></li><li><a href="/nav/code/sort/插入排序.html" class="nav-link-new"><span class="nav-link-new">插入排序</span></a></li><li><a href="/nav/code/sort/希尔排序.html" class="nav-link-new"><span class="nav-link-new">希尔排序</span></a></li><li><a href="/nav/code/sort/归并排序.html" class="nav-link-new"><span class="nav-link-new">归并排序</span></a></li><li><a href="/nav/code/sort/快速排序.html" class="nav-link-new"><span class="nav-link-new">快速排序</span></a></li></ul></div></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/code/search/index.html" class="nav-link-new"><span class="nav-link-new">查找</span></a></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/code/picture/index.html" class="nav-link-new"><span class="nav-link-new">图</span></a></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/code/string/index.html" class="nav-link-new"><span class="nav-link-new">字符串</span></a></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/code/rremark/index.html" class="nav-link-new"><span class="nav-link-new">笔记</span></a></li></ul></div></div><div class="nav-item"><a href="https://github.com/JhonLandy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  联系我
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/JhonLandy/webDev" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></header> <div class="sidebar-mask" data-v-46e9af19></div> <aside class="sidebar" data-v-46e9af19><nav class="nav-links"><div class="nav-item"><a href="/index.html" class="nav-link"><span class="nav-link">首页</span></a></div><div class="nav-item"><div class="dropdown-wrapper el-dropdown"><span class="el-dropdown-link"><span class="nav-link"> 前端 </span> <i class="el-icon-arrow-down el-icon--right"></i></span> <ul class="el-dropdown-menu el-popper" style="display:none;"><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> Javascript </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/web/javascript/ES6/index.html" class="nav-link-new"><span class="nav-link-new">ES6</span></a></li><li><a href="/nav/web/javascript/object/index.html" class="nav-link-new"><span class="nav-link-new">对象、类面向对象编程</span></a></li><li><a href="/nav/web/javascript/promise/index.html" class="nav-link-new"><span class="nav-link-new">期约与异步函数</span></a></li><li><a href="/nav/web/javascript/canvas/index.html" class="nav-link-new"><span class="nav-link-new">动画与Canvas图形</span></a></li><li><a href="/nav/web/javascript/form/index.html" class="nav-link-new"><span class="nav-link-new">表单脚本</span></a></li><li><a href="/nav/web/javascript/网络请求与远程资源.html" class="nav-link-new"><span class="nav-link-new">网络请求与远程资源</span></a></li><li><a href="/nav/web/javascript/工作者线程.html" class="nav-link-new"><span class="nav-link-new">工作者线程</span></a></li></ul></div></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/web/typescript/index.html" class="nav-link-new"><span class="nav-link-new">Typescript</span></a></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> Css </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/web/css/layout/index.html" class="nav-link-new"><span class="nav-link-new">布局</span></a></li><li><a href="/nav/web/css/animation/index.html" class="nav-link-new"><span class="nav-link-new">动画</span></a></li></ul></div></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> Vue </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/web/vue/api/index.html" class="nav-link-new"><span class="nav-link-new">基本使用</span></a></li></ul></div></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper el-dropdown"><span class="el-dropdown-link"><span class="nav-link"> 部署 </span> <i class="el-icon-arrow-down el-icon--right"></i></span> <ul class="el-dropdown-menu el-popper" style="display:none;"><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> docker </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/deployment/docker/base/index.html" class="nav-link-new"><span class="nav-link-new">基本命令</span></a></li></ul></div></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> Git </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/deployment/git/command/index.html" class="nav-link-new"><span class="nav-link-new">常用命令</span></a></li><li><a href="/nav/deployment/git/standard/index.html" class="nav-link-new"><span class="nav-link-new">提交规范</span></a></li><li><a href="/nav/deployment/git/ssh/index.html" class="nav-link-new"><span class="nav-link-new">SSH</span></a></li></ul></div></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/deployment/CICD/index.html" class="nav-link-new"><span class="nav-link-new">CI/CD</span></a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper el-dropdown"><span class="el-dropdown-link"><span class="nav-link"> 算法与数据结构 </span> <i class="el-icon-arrow-down el-icon--right"></i></span> <ul class="el-dropdown-menu el-popper" style="display:none;"><li tabindex="-1" class="el-dropdown-menu__item"><!----><div><div class="title"><span class="nav-link-new"> 排序 </span> <i class="el-icon-arrow-down el-icon--right"></i></div> <ul class="meun"><li><a href="/nav/code/sort/选择排序.html" class="nav-link-new"><span class="nav-link-new">选择排序</span></a></li><li><a href="/nav/code/sort/插入排序.html" class="nav-link-new"><span class="nav-link-new">插入排序</span></a></li><li><a href="/nav/code/sort/希尔排序.html" class="nav-link-new"><span class="nav-link-new">希尔排序</span></a></li><li><a href="/nav/code/sort/归并排序.html" class="nav-link-new"><span class="nav-link-new">归并排序</span></a></li><li><a href="/nav/code/sort/快速排序.html" class="nav-link-new"><span class="nav-link-new">快速排序</span></a></li></ul></div></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/code/search/index.html" class="nav-link-new"><span class="nav-link-new">查找</span></a></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/code/picture/index.html" class="nav-link-new"><span class="nav-link-new">图</span></a></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/code/string/index.html" class="nav-link-new"><span class="nav-link-new">字符串</span></a></li><li tabindex="-1" class="el-dropdown-menu__item"><!----><a href="/nav/code/rremark/index.html" class="nav-link-new"><span class="nav-link-new">笔记</span></a></li></ul></div></div><div class="nav-item"><a href="https://github.com/JhonLandy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  联系我
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/JhonLandy/webDev" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>糯米学习笔记</span> <!----></p> <!----></section></section></li><li><section><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></section></li><li><section><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></section></li><li><section><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></section></li><li><section><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></section></li><li><section><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></section></li><li><section><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></section></li><li><section><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VueRouter原理解析</span> <span class="arrow right"></span></p> <!----></section></section></li><li><section><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></section></li><li><section><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>jest</span> <span class="arrow right"></span></p> <!----></section></section></li><li><!----></li><li><section><a href="/sidebar/manager/前端管理.html" class="sidebar-link">前端管理学习</a></section></li><li><section><a href="/sidebar/article/好文收集.html" class="sidebar-link">好文收集</a></section></li></ul> </aside> <main class="page" data-v-46e9af19> <div class="theme-default-content content__default"><p><big>作者：糯米</big></p> <p><big>日期：2021年2月10号</big></p> <h1 id="源计划"><a href="#源计划" class="header-anchor">#</a> 源计划</h1> <h2 id="javascript"><a href="#javascript" class="header-anchor">#</a> javascript</h2> <h3 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h3> <h3 id="谈谈你对原型链的理解-✨"><a href="#谈谈你对原型链的理解-✨" class="header-anchor">#</a> 谈谈你对原型链的理解？ ✨</h3> <p>原型是一个对象或者类实例的一个数据共享区。访问对象或者类实例的属性或方法时，先查找自身的属性或方法，如果找不到，继续查找原型。例如函数的portotype就是原型属性。</p> <p>原型中保存着着另一个原型的引用，另一个原型又保存着另一个原型的引用，像这样的引用关系就叫做原型链。访问对象或者类实例的属性或方法时，先查找自身的属性或方法，如果找不到，继续查找原型，如果还找不到，继续查找下一个原型，直到结束，如果还找不到，返回undefind。对象或类实例通过继承实方式现原型链，能够复用父类对象，实例中的属性和方法。
我们还可以 通过hasOwnProperty判断属性是否在原型上，true表示不在。</p> <h3 id="如何判断是否是数组"><a href="#如何判断是否是数组" class="header-anchor">#</a> 如何判断是否是数组？</h3> <p>Array.isArray、instance of Array</p> <h3 id="es6模块与commonjs模块有什么区别"><a href="#es6模块与commonjs模块有什么区别" class="header-anchor">#</a> ES6模块与CommonJS模块有什么区别？</h3> <p>同步和异步是在于程序中的各个任务是否按顺序执行，异步操作可以改变程序的正常执行顺序。
阻塞和非阻塞就是发起调度，会不会挂起当前线程，停止执行代码，直到调度完才继续执行代码。
<br>
异步加载：不按代码执行顺序加载。
<br>
同步加载：按照代码的执行顺序加载，什么时候执行代码发起调度就什么时候调度。</p> <h4 id="amd"><a href="#amd" class="header-anchor">#</a> AMD:</h4> <p>异步加载模块，不阻塞html等其他资源的加载（不阻塞线程），回调函数遵循时间循环（不一定按顺序执行）</p> <h4 id="commonjs"><a href="#commonjs" class="header-anchor">#</a> CommonJS</h4> <p>1.单例模式
2.同步加载，按顺序执行代码，同时会阻塞当前代码执行（挂起当前线程）
3. 当有导入的时候（import或require）,都会暂停当前模块执行的代码，
4. 接口执行声明</p> <h4 id="es6"><a href="#es6" class="header-anchor">#</a> es6:</h4> <ol><li>不是单例模式，动态声明
2.异步加载（挂起当前线程，先加载执行，之后再执行当前代码），不按顺序执行代码（异步），会挂起当前线程（阻塞）
3.当有导入的时候（import或require）,都会暂停当前模块执行的代码，并产生一些奇妙的效果。（export fn,函数声明）（浏览器环境）</li> <li>不能重新赋值</li> <li>代码静态分析，接口编译时声明</li></ol> <h4 id="区别"><a href="#区别" class="header-anchor">#</a> 区别：</h4> <p>CommonJS先require同步加载（require时才加载执行，有一定的阻塞,更适合服务器，读取文件无需请求下载)，ES6异步加载（先加载执行完所有模块，再来执行当前代码（当前代码的函数声明会比加载模块靠前完成），适合浏览器）
commonJS使用的module.exports导出（对象是浅拷贝），es6采用export default等语法导出，导出的对象是直接引用。
es6 导出的对象不能重新赋值（会报错），commonjs不会.</p> <ul><li><p>聊⼀聊如何在JavaScript中实现不可变对象？</p></li> <li><p>JavaScript的参数是按照什么⽅式传递的？</p></li> <li><p>js有哪些类型?
number,string,null,undefind,boolean</p></li> <li><p>为什么会有BigInt的提案？</p></li> <li><p>null与undefined的区别是什么？
null 表示 空值</p></li></ul> <p>undefind表示 不是空值，表示值不存在</p> <h3 id="_0-1-0-2为什么不等于0-3"><a href="#_0-1-0-2为什么不等于0-3" class="header-anchor">#</a> 0.1+0.2为什么不等于0.3？</h3> <p>首先，计算时要将小数的10进制转换为标准机器读懂的编码，在这个过程中，因为位数原因，造成精度会顺损失，导致计算出的结果大于0.3</p> <h3 id="类型转换的规则有哪些"><a href="#类型转换的规则有哪些" class="header-anchor">#</a> 类型转换的规则有哪些？</h3> <p>if语句，while,==，数学运算符</p> <h3 id="类型转换的原理是什么"><a href="#类型转换的原理是什么" class="header-anchor">#</a> 类型转换的原理是什么？</h3> <p>当遇到转换规则时，则在内部代码会判断 值类型，好比如[] + 1,先调用valueOf()方法，发现类型不是原始值类型，接着再调用toString(),最后[]得到 &quot;&quot;转换，相当于&quot;&quot;+1,结果为&quot;1&quot;</p> <h3 id="js机制"><a href="#js机制" class="header-anchor">#</a> js机制</h3> <h3 id="解释下变量提升-✨"><a href="#解释下变量提升-✨" class="header-anchor">#</a> 解释下变量提升？✨</h3> <p>javascript代码在真正执行前会根据词法环境注册var、let、const声明的变量及声明函数。首先会进行函数的声明，给对应的标识符进行函数绑定，若标识符已存在，则覆盖之前的值。然后进行变量的声明。 若该变量（标识符）没注册过，则默认等于undefind。若声明了变量或函数，并在声明变量或函数语句前执行console.log打印变量，如果是变量则打印undefind，如果是函数则打印函数体。但let，const会报错，因为console.log处于暂时性死区。</p> <h3 id="一段javascript代码是如何执行的-✨"><a href="#一段javascript代码是如何执行的-✨" class="header-anchor">#</a> ⼀段JavaScript代码是如何执⾏的？✨</h3> <p>javascript是逐行执行的，执行的时候，首先会创建一个全局执行上下文，执行上下文里有词法环境，函数上下文等执行所需的变量，当遇到一个执行函数时，引擎会停止当前执行上下文的执行，创建一个函数执行上下文，并，压入执行栈，执行栈是用来管理跟踪当前执行上下文的位置，保存着全局执行上下文和所有的函数执行上下文，当函数执行完毕时，函数执行上下文弹出执行栈，相关的作用域等数据也随之回收，继续执行全局执行上下文。当前执行全局代码相当于执行宏任务，如果遇到宏任务，则把宏任务放到宏任务队列，等待下一次时间循环，如果是微任务，则放到微任务队列，等待在下一次宏任务执行前全部执行完毕。</p> <h3 id="javascript的作用域链理解吗-✨"><a href="#javascript的作用域链理解吗-✨" class="header-anchor">#</a> JavaScript的作⽤域链理解吗？✨</h3> <p>作用域就是在函数执行上下文中用于查找变量或函数。作用域又称词法环境，当函数执行时，就会生成，用于跟踪函数中声明的变量和函数。let、const声明的变量保存在块级作用域，var声明的变量放在名为local作用域。作用作用域有可能引用着父级作用域。</p> <h3 id="谈一谈你对this的了解-✨"><a href="#谈一谈你对this的了解-✨" class="header-anchor">#</a> 谈⼀谈你对this的了解？✨</h3> <p>this指的函数上下文，和函数执行上下文不是一个东西。this相当于一个动态的作用域，函数中，this可以是指向一个对象或全局对象window，或者undefind。通过call，bind，apply可以修改函数this的指向，严格模式下，this为undefind，在箭头函数中，this指向箭头函数所在执行上下文的函数上下文。</p> <h3 id="箭头函数的this指向哪里-✨"><a href="#箭头函数的this指向哪里-✨" class="header-anchor">#</a> 箭头函数的this指向哪⾥？✨</h3> <p>this指向箭头函数所在执行上下文的函数上下文</p> <h3 id="理解闭包吗-✨"><a href="#理解闭包吗-✨" class="header-anchor">#</a> 理解闭包吗？✨</h3> <p>闭包就是作用域的特殊应用（个人感觉差别不大）。在外部函数内声明内部函数时，闭包就创建了。闭包保存着内部函数所需要变量或函数（内部函数作用域没有的），并存在于作用域链上。只要有函数引用着闭包就不会消失（可能会引起内存泄漏问题），请不要多度使用闭包，或者清空无用的函数。（let fn = null）</p> <h3 id="实现bind和call两个方法"><a href="#实现bind和call两个方法" class="header-anchor">#</a> 实现bind和call两个方法</h3> <div class="language-js extra-class"><pre class="language-js"><code>
Function<span class="token punctuation">.</span>portotype<span class="token punctuation">.</span><span class="token function-variable function">call</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">content<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    content<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    content<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
Function<span class="token punctuation">.</span>portotype<span class="token punctuation">.</span><span class="token function-variable function">apply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">content <span class="token operator">=</span> window<span class="token punctuation">,</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    content<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    content<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
Function<span class="token punctuation">.</span>portotype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">content <span class="token operator">=</span> window<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>local</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          content <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">)</span>
        content<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">return</span> result
    <span class="token punctuation">}</span>
    fn<span class="token punctuation">.</span>portotype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>portotype<span class="token punctuation">)</span>
    <span class="token keyword">return</span> fn
<span class="token punctuation">}</span>

</code></pre></div><h3 id="js内存"><a href="#js内存" class="header-anchor">#</a> js内存</h3> <h3 id="讲讲javascript垃圾回收是怎么做的"><a href="#讲讲javascript垃圾回收是怎么做的" class="header-anchor">#</a> 讲讲JavaScript垃圾回收是怎么做的？</h3> <p>js对象 种类分为分新生代和老生代，新生代分配的攻坚比老生代小很多，新生代主要存储着很快不用的对象，老生代存储着长期存活的对象（window等），新生代的对象在多次回收中都没被回收，会晋升为老生代。变量那些数据会随着 执行上下文的销毁被回收。回收垃圾前，会对对象进行标记，从根对象往下遍历并标记，能遍历的为可达，不能遍历为不可达，之后会回收不可达的对象。</p> <h3 id="javascript的基本类型和复杂类型是储存在哪里的"><a href="#javascript的基本类型和复杂类型是储存在哪里的" class="header-anchor">#</a> JavaScript的基本类型和复杂类型是储存在哪⾥的？</h3> <p>基本类型存储在栈内存里面，复杂类型存储在堆内存</p> <h3 id="异步"><a href="#异步" class="header-anchor">#</a> 异步</h3> <h3 id="async-await-是什么"><a href="#async-await-是什么" class="header-anchor">#</a> async/await 是什么？</h3> <p>async/await 是 promise的语法糖，允许 一组 promise 对象 按照一定顺序执行。</p> <ol><li>async声明一个异步函数</li> <li>异步函数默认返回promise对象</li> <li>异步函数内部执行到await时，会暂停当前执行上下文执行，直到promise 有返回结果</li> <li>await 只能在异步函数使用</li> <li>异步函数中所有的promise执行完成后，异步函数返回的promise对象才会执行then方法</li></ol> <p>与promise的优势：
解决回调地狱，以同步方式编写代码，代码更加优雅
方便调试</p> <h3 id="dom"><a href="#dom" class="header-anchor">#</a> dom</h3> <ul><li>DOM的事件模型是什么？
脚本模型，内联模型，动态绑定</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!--⾏内绑定：脚本模型--&gt;</span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>javascrpt:alert(<span class="token punctuation">'</span>Hello<span class="token punctuation">'</span>)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Hello1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span> 
<span class="token comment">&lt;!--内联模型--&gt;</span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>showHello()<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Hello2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span> 
<span class="token comment">&lt;!--动态绑定--&gt;</span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>btn3<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Hello3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li>DOM的事件流是什么？
事件流又称为事件传播，指发生 行为交互时触发相应事件，触发时按照一定顺序传递事件。事件传播分为三个阶段，捕获阶段，目标阶段，冒泡阶段。当事件发生时，先触发，捕获事件，再触发目标事件，最后再触发冒泡事件，一直往上冒泡。</li> <li>什么是事件委托?
在元素的最外部元素统一绑定事件，最外部元素内部的任何元素无需绑定事件，只要触发事件，事件就会冒泡到最外部元素，执行绑定的事件。</li></ul> <ol><li>好处
减少内存占用</li> <li>坏处
focus、blur 之类的事件本身没有事件冒泡机制，所以⽆法委托
mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗⾼，不适 合事件委托</li></ol> <h3 id="bom"><a href="#bom" class="header-anchor">#</a> bom</h3> <h2 id="css"><a href="#css" class="header-anchor">#</a> css</h2> <h3 id="基础-2"><a href="#基础-2" class="header-anchor">#</a> 基础</h3> <h3 id="css选择器的优先级是怎样的-✨"><a href="#css选择器的优先级是怎样的-✨" class="header-anchor">#</a> CSS选择器的优先级是怎样的？✨</h3> <p>不同选择的优先级不一样。如果按优先级分类abcd,a包含行内样式（1），b包含id选择器，c包含类选择器，伪类和属性选择符个数（n）,d包含类型选择器和伪元素个数。abcd不同种类的选择器个数按照abcd顺序拼接，得到的值最大的，优先级最大</p> <ul><li>link和@import的区别？</li></ul> <p>link：</p> <ol><li>可以并发加载</li> <li>没有兼容问题</li></ol> <p>import:</p> <ol><li>增加请求数目,增加网络开销（移动端）
（影响页面加载速率）</li> <li>不会和link标签并发加载，等待link标签加载完再加载，在ie下，等待所有link加载完再加载，导致屏幕闪烁，或者覆盖js的样式</li> <li>兼容ie5以上</li> <li></li></ol> <p>建议会用link，尽量少用import</p> <h3 id="有哪些方式-css-可以隐藏⻚面元素"><a href="#有哪些方式-css-可以隐藏⻚面元素" class="header-anchor">#</a> 有哪些⽅式（CSS）可以隐藏⻚⾯元素？</h3> <p>display:none
visbility:hidden
opacity: 0</p> <h3 id="em-px-rem区别"><a href="#em-px-rem区别" class="header-anchor">#</a> em\px\rem区别？</h3> <p>他们都会字体大小的单位。
px是一个基础的单位，描述字体显示的大小
em 是基于父级元素字体大小来计算，如父元素字体为12px，子元素1em，那么子元素字体大小就是(12 x 1 )px
rem 是基于html字体大小来计算,同理em</p> <h3 id="块级元素水平居中的方法"><a href="#块级元素水平居中的方法" class="header-anchor">#</a> 块级元素⽔平居中的⽅法？</h3> <div class="language-css extra-class"><pre class="language-css"><code> <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>

 // 定位
 position：absolute

 left：50% - 自身宽度一半
// 动画
<span class="token property">tranform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>50%<span class="token punctuation">,</span> 0<span class="token punctuation">)</span>
 // 弹性盒子
 父元素 <span class="token property">display</span><span class="token punctuation">:</span> flex
 子元素 jusify-content：center

</code></pre></div><h3 id="块级元素水平垂直的方法"><a href="#块级元素水平垂直的方法" class="header-anchor">#</a> 块级元素⽔平垂直的⽅法？</h3> <div class="language-css extra-class"><pre class="language-css"><code><span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
<span class="token property">veritical-aligin</span><span class="token punctuation">:</span>middle
// 弹性布局
父元素 <span class="token property">display</span><span class="token punctuation">:</span> flex
子元素 align-items：center

// 定位
position：absolute
top：50% - 自身高度度一半

// 动画
<span class="token property">tranform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span>
</code></pre></div><h3 id="块级盒子"><a href="#块级盒子" class="header-anchor">#</a> 块级盒子</h3> <p>div,p,section,ui,li,aside,meun,ol,dl,canvas,h1~h6,table,pre,footer,main,center(center已废弃)</p> <h3 id="行内盒子"><a href="#行内盒子" class="header-anchor">#</a> 行内盒子</h3> <p>span,a,strong,u,var,small,label,input,select</p> <h3 id="css有几种定位方式"><a href="#css有几种定位方式" class="header-anchor">#</a> CSS有⼏种定位⽅式？</h3> <p>3种。</p> <ol><li>static默认的。</li> <li>absolute。参考包含块（position为非static）定位（top,left）,r如果没有可参考的position包含块，就以html根元素作为包含块参考。不占用原来空间</li> <li>relative。参考原来的位置做偏移，偏移后仍占据原来的空间</li> <li>fixed 相对于浏览器窗口进行定位。</li></ol> <ul><li>如何理解z-index？✨
z-index属性 控制 层叠上下文中层叠元素次序。
层叠上下文中 不同元素 层叠顺序不一样。它们是按照这样的规则排序。z-index 为 负 positioned元素 &gt; 非positioned block元素 &gt; 非positioned float元素 &gt;  非positioned inline元素 &gt; positioned z-index为0或者auto的元素 &gt; positioned (z-index &gt; 1 )元素.z-index 控制 positioned元素离屏幕的距离（堆叠次序）</li></ul> <h3 id="如何理解层叠上下文-✨"><a href="#如何理解层叠上下文-✨" class="header-anchor">#</a> 如何理解层叠上下⽂？✨</h3> <p>z-index 不为auto的定位元素会在 一定 空间按照 堆叠次序 排序（里屏幕的距离），这个空间就叫做层叠上下文。z-index不为auto的定位元素、opacity小于1 的元素、ransform 属性值不为 none的元素、perspective 值不为 none 的元素都会创建自己的层叠上下文，层叠上下文的堆叠次序，不会影响外部的堆叠次序。</p> <h3 id="清除浮动有哪些方法"><a href="#清除浮动有哪些方法" class="header-anchor">#</a> 清除浮动有哪些⽅法？</h3> <ol><li>给 父元素 添加伪元素</li> <li>给父元素设置为BFC（块级格式化上下文），如：overflow 不是 visible元素、绝对定位元素、浮动元素、display为inline-block元素。</li></ol> <h3 id="你对css-sprites的理解"><a href="#你对css-sprites的理解" class="header-anchor">#</a> 你对css-sprites的理解</h3> <p>css-sprite就是雪碧图，把许多图片整合到一张图，减少网页请求次数，提升网页加载速度，提高体验。以后有图标要扩展的时候，只需在一张图添加就可以了。很方便。</p> <ul><li>你对媒体查询的理解？</li></ul> <h3 id="你对盒模型的理解-✨"><a href="#你对盒模型的理解-✨" class="header-anchor">#</a> 你对盒模型的理解？✨</h3> <p>页面中所有元素都看作是一个矩形盒子，这个盒子包含元素的内容，内边距(padding)，外边距（marign），边框(border)。我们通过css样式（浮动，定位，行内块）设置盒子的属性（宽高，边框）和布局。盒子有块级盒子，行内盒子（在行盒子里头）。常规块级盒子里有相邻外边距折叠（折叠发生在常规块级盒子，行内盒子，浮动元素，绝对定位盒子（absolute或fixed）不会发生外边距折叠）等特性，垂直外边距对行内盒子没影响等特性。当然可以通过border-sizing：border-box改变计算盒子的大小方式。</p> <ul><li>标准盒模型和怪异盒模型有什么区别？✨</li></ul> <h3 id="谈谈对bfc-block-formatting-context-的理解-✨"><a href="#谈谈对bfc-block-formatting-context-的理解-✨" class="header-anchor">#</a> 谈谈对BFC(Block Formatting Context)的理解？ ✨</h3> <p>BFC顾名思义就是块级格式化上下文。overflow不为auto的元素，浮动元素，绝对定位，display为inline-block之类的元素都可以自己创建内部的块级格式化上下文。BFC中，会有外边距重叠（相邻的外边距会重合，取最大值），会自动包含 浮动元素。块级盒子左边距默认和包含块左边距对齐。防止文字环绕浮动元素。防止相邻元素外边距重叠（但同一个bfc上下文会发生外边距折叠，只能防止不同bfc元素外边距折叠）</p> <h3 id="为什么有时候人们用translate来改变位置而不是定位"><a href="#为什么有时候人们用translate来改变位置而不是定位" class="header-anchor">#</a> 为什么有时候⼈们⽤translate来改变位置⽽不是定位？</h3> <p>translate性能比 定位性能要好。因为 定位会放生浏览器重绘和复合，translate只会发生复合；tranlate会创建一个GPU图层使用，定位元素却是用cpu，tranlate更高效。</p> <h3 id="伪类和伪元素的区别是什么"><a href="#伪类和伪元素的区别是什么" class="header-anchor">#</a> 伪类和伪元素的区别是什么？</h3> <p>伪类：如:focus,:link,:visited,:active,:hover,用于给元素在特定状态添加样式
伪元素: 如:before,:after,:first-letter(第一行)。可以减少页面 元素的个数，无需添加额外的元素标签就可以给页面添加css效果</p> <h3 id="你对flex的理解-✨"><a href="#你对flex的理解-✨" class="header-anchor">#</a> 你对flex的理解？✨</h3> <ul><li><p>flex布局是一维布局，控制垂直、水平方向的排序方式， 有交叉轴和主轴，主轴默认是水平方向。二位布局的有grid布局。</p></li> <li><p>flex的直系子元素就是felx元素，flex元素有以下特性：</p> <ol><li>水平方向自动排序。</li> <li>宽度不会拉伸，可以被压缩。</li> <li>高度会被自适应拉伸</li> <li>不会自动换行</li> <li>里面的非定位元素也可以通过z-index控制层叠次序（网格布局同理）</li></ol></li> <li><p>属性</p> <ol><li>row-reverse 或 row-cloumns 改变 某个方向的排序方向</li> <li>flex-direction 改变默认的主轴方向</li> <li>flex-wrap 設置是否換行</li> <li>flex-grink/flex-grow/flex-basic控制伸縮比例，寬度</li> <li>justify-content 用来使元素在主轴方向上对齐</li> <li>align-item 控制flex元素在交错轴的排序方式，（单行）</li> <li>align-ocntent （多行）</li> <li>align-self 只控制flex元素自身</li></ol></li> <li><p>优势：
可用于设置水平方向的布局。解决行内块（留白问题），浮动（浮动元素不能随空间变化而变化），表格水平布局（不能应用外边距，不能排序）带来的一些问题。flex布局会忽略float和display属性（通常设置float和display用于向后兼容），少量代码可以简单实现水平布局。里面的非定位元素也可以通过z-index控制层叠次序（网格布局同理）</p></li> <li><p>缺陷：
不好的就是，刚打开页面时，元素开始计算（变大），造成页面跳动的，体验不好，通常给元素设置固定宽高，可以减少影响。</p></li></ul> <h3 id="关于css的动画与过渡问题"><a href="#关于css的动画与过渡问题" class="header-anchor">#</a> 关于CSS的动画与过渡问题</h3> <h3 id="css3新特性"><a href="#css3新特性" class="header-anchor">#</a> css3新特性</h3> <h5 id="box-reflect-倒影-含图片遮罩"><a href="#box-reflect-倒影-含图片遮罩" class="header-anchor">#</a> box-reflect(倒影，含图片遮罩)</h5> <div class="language-css extra-class"><pre class="language-css"><code>  <span class="token property">-webkit-box-reflect</span><span class="token punctuation">:</span>方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片
</code></pre></div><p style="height:649px;"><img src="https://img0.baidu.com/it/u=103721101,4076571305&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg" style="box-reflect:below 0 url(https://segmentfault.com/img/bVTepE?w=200&amp;h=200);"></p> <h5 id="text-shadow-文字阴影"><a href="#text-shadow-文字阴影" class="header-anchor">#</a> text-shadow(文字阴影)</h5> <div class="language-css extra-class"><pre class="language-css"><code><span class="token property">text-shadow</span><span class="token punctuation">:</span> 水平阴影，垂直阴影，模糊的距离，以及阴影的颜色
</code></pre></div><p style="text-shadow:0 0 10px #f00;">哈喽</p> <h5 id="background-blend-mode-mix-blend-mode混合模式"><a href="#background-blend-mode-mix-blend-mode混合模式" class="header-anchor">#</a> background-blend-mode/mix-blend-mode混合模式</h5> <h5 id="filter-滤镜"><a href="#filter-滤镜" class="header-anchor">#</a> Filter(滤镜)</h5> <h5 id="渐变"><a href="#渐变" class="header-anchor">#</a> 渐变</h5> <ul><li>线性渐变（-webkit-linear-gradient)</li> <li>径向渐变（-webkit-radial-gradient)</li></ul> <h5 id="颜色"><a href="#颜色" class="header-anchor">#</a> 颜色</h5> <ul><li>rgba(rgb为颜色值，a为透明度）</li> <li>hsla(h:色相”，“s：饱和度”，“l：亮度”，“a：透明度”)</li></ul> <h5 id="background-clip-绘制-显示-区域"><a href="#background-clip-绘制-显示-区域" class="header-anchor">#</a> background-clip(绘制（显示）区域)</h5> <ul><li>border-box （默认值，从边框绘制）</li> <li>padding-box(从padding绘制)</li> <li>content-box(从内容绘制)</li></ul> <h2 id="html"><a href="#html" class="header-anchor">#</a> html</h2> <h3 id="doctype-文档类型-的作用是什么-✨"><a href="#doctype-文档类型-的作用是什么-✨" class="header-anchor">#</a> doctype(⽂档类型) 的作⽤是什么？✨</h3> <p>声明浏览器解析类型，声明浏览器按照html5的标准解析 html和css内容。</p> <p>浏览器浏览的类型有 怪异模式（不声明doctype，默认是这个模式），标准模式。
js通过 window.document.compatMode可以知道 当前浏览器模式。
怪异模式下，盒子的宽度是包括 边跨 + 内边距 + 实际内容，怪异盒子，还有一些css不被浏览器识别 ！important。</p> <p>标准模式下，浏览器按照w3c标准解析文档，就算是跨浏览器也不会出现页面不一致问题。</p> <h3 id="这三种模式的区别是什么-接上一问追问"><a href="#这三种模式的区别是什么-接上一问追问" class="header-anchor">#</a> 这三种模式的区别是什么？(接上⼀问追问)</h3> <p>怪异模式下，盒子的宽度是包括 边跨 + 内边距 + 实际内容，怪异盒子，还有一些css不被浏览器识别 ！important。</p> <p>标准模式下，浏览器按照w3c标准解析文档，就算是跨浏览器也不会出现页面不一致问题。</p> <p>ie8有一介于两种模式之间的模式（基本淘汰）</p> <h3 id="html、xml-和-xhtml-有什么区别"><a href="#html、xml-和-xhtml-有什么区别" class="header-anchor">#</a> HTML、XML 和 XHTML 有什么区别？</h3> <p>HTML(超⽂本标记语⾔):就是我们平时所用到的html元素
XML（可扩展标记语⾔）：是一种通用的数据传输 标准（不管是在什么地方），作用和json类似。
XHTML（可扩展超⽂本标记语⾔)）：以前html4版本以前 标准比较混乱，所以XHTML是HTML的新规范（用xml规范html），通过开头doctype 声明。现在XHTML被淘汰了，现在是HTML5新一代的规范。</p> <h3 id="什么是data-属性"><a href="#什么是data-属性" class="header-anchor">#</a> 什么是data-属性？</h3> <p>html的数据属性，可以通过js操作dom的dataset属性获取数据（ie9）.有了前端框架，现在不流行了</p> <h3 id="你对html语义化的理解-✨"><a href="#你对html语义化的理解-✨" class="header-anchor">#</a> 你对HTML语义化的理解？✨</h3> <p>使用恰当语气的表情，如文章就是用article。
好处：
更好的seo，提升搜索排名
对开发者友好，标签知名达意，增强可读性，能够清晰看出网页结构，便于维护（避免div麻疹）
能够让阅读器理解，帮助听力有障碍的人阅读</p> <h3 id="html5与html4的不同之处"><a href="#html5与html4的不同之处" class="header-anchor">#</a> HTML5与HTML4的不同之处</h3> <ol><li>⽂件类型声明（&lt;!DOCTYPE&gt;）仅有⼀型：&lt;!DOCTYPE HTML&gt;。</li> <li>新的解析顺序：不再基于SGML。</li> <li>新的元素：section, video, progress, nav, meter, time, aside, canvas, command, datalist, details, embed, figcaption, figure, footer, header, hgroup, keygen, mark, output, rp, rt, ruby, source, summary, wbr。 input元素的新类型：date, email, url等等。</li> <li>新的属性：ping（⽤于a与area）, charset（⽤于meta）, async（⽤于script）。</li></ol> <h3 id="有哪些常用的meta标签"><a href="#有哪些常用的meta标签" class="header-anchor">#</a> 有哪些常⽤的meta标签？</h3> <div class="language-html extra-class"><pre class="language-html"><code>//设置移动端 显示
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1, maximum-scale=1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>

initial-scale 初始显示的比例，1表示默认尺寸
maximum-scale 最大可放大的比例，1表示不能的放大
//设置http缓存过期日期
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>expires<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Wed, 20 Jun 2019 22:33:00 GMT<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>

//设置文档格式
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="src和href的区别"><a href="#src和href的区别" class="header-anchor">#</a> src和href的区别？</h3> <p>src指向的外部资源，通过src指定的资源地址，会请求下载外部资源，并（执行）应用到文档，如css，js
href是 指网络资源的地址，通常是连接标签元素和 其他文档，如果地址是指向文件，会现在文件。</p> <h3 id="知道img的srcset的作用是什么-追问"><a href="#知道img的srcset的作用是什么-追问" class="header-anchor">#</a> 知道img的srcset的作⽤是什么？（追问）</h3> <p>srcset数属性是用来设置响应式图片。因为在手机端上或者分辨率很小的设备上，不需要很大的图片，这样会造成更多流量的使用（用户可能不愿意）和 很多的处理器处理时间和内存。srset属性设置一组图片的地址（逗号分隔），根据不同设备的分辨率下载对应的图片（这个和浏览器的算法有关）。如果不需要根据分辨率大小来切换图片，也可以设置sizes属性（媒体所声明的宽度）去选择图片（声明宽度 * 物理像素与css像素比 &lt; srcset 声明的宽度描述值（400w））</p> <h3 id="还有哪一个标签能起到跟srcset相似作用-追问"><a href="#还有哪一个标签能起到跟srcset相似作用-追问" class="header-anchor">#</a> 还有哪⼀个标签能起到跟srcset相似作⽤？（追问）</h3> <p>picture.一个picture可以包含多个source，如果浏览器匹配到合适的source，就让source要显示的内容在img上显示，如果浏览器不支持该语法和没有匹配到，则img标签的src作为兜底属性。</p> <h3 id="script标签中defer和async的区别-✨"><a href="#script标签中defer和async的区别-✨" class="header-anchor">#</a> script标签中defer和async的区别？✨</h3> <p>他们都是script便签上的属性，都是让js文件进行异步加载。defer规定脚本在dom解析完后按照下载顺序执行。async先下载完先执行（有先后依赖关系的情况，并不适⽤），可能会阻塞html解析，也有可能导致获取不到没解析的dom元素。</p> <h3 id="有几种前端储存的方式-这些方式的区别是什么-✨"><a href="#有几种前端储存的方式-这些方式的区别是什么-✨" class="header-anchor">#</a> 有⼏种前端储存的⽅式，这些⽅式的区别是什么？✨</h3> <p>localStorage，sessionStorage， cookie，indexDB，Web SQL</p> <ul><li>localStorage可以存储 5m大的数据，不手动清除，是不会随着浏览器推出而清除。</li> <li>sessionStorag同样是5m的数据，浏览器tab退出时就会清除数据，有相关事件，不能在同源窗口公用，会话级别存储。</li> <li>cookie，通常只能存储4kb的数据，通常不会存放敏感的数据，会自动随着请求头带到服务器，</li> <li>indexDB，是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快 速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常⽅便</li> <li>Web SQL 2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实 现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换， 较为繁琐。</li></ul> <h2 id="http"><a href="#http" class="header-anchor">#</a> http</h2> <h3 id="http有哪些方法-这些方法的具体作用是什么"><a href="#http有哪些方法-这些方法的具体作用是什么" class="header-anchor">#</a> HTTP有哪些⽅法？这些⽅法的具体作⽤是什么？</h3> <ol><li>GET</li></ol> <ul><li>无请求体</li> <li>有响应体</li> <li>安全（不会修改服务器状态）</li> <li>冥等（发请求多次的过也是等于一次的效果）</li> <li>缓存</li> <li>可用于表单提交</li></ul> <ol start="2"><li>POST（增删查改，但不是标准，增加一条数据不要用patch）</li></ol> <ul><li>有请求体</li> <li>有响应体</li> <li>不是幂等，多次调用多次请求，多次改变服务器状态（如增加一条数据）</li> <li>不安全（会改变服务器状态）</li> <li>可用于表单提交</li> <li>有效缓存（仅当包含新鲜度信息时）</li></ul> <ol start="3"><li>PUT（对已知的资源进行替换；替换资源）</li></ol> <ul><li>有请求体</li> <li>没有响应体</li> <li>冥等</li> <li>不安全</li> <li>不缓存</li> <li>不可用于表单提交</li></ul> <ol start="4"><li>OPTION （预检测）</li> <li>DELETE （删除资源）</li></ol> <ul><li>没请求体</li> <li>没响应体</li> <li>冥等（多次删除同一id的数据，会返回404）</li> <li>不能等用于 表单</li> <li>不能缓存</li> <li>不安全</li></ul> <ol start="6"><li>CONNECT（建立隧道，发送tcp流）</li> <li>TRACER（用于调试才测试）</li> <li>PATCH（对已知资源进⾏局部更新、修改）</li></ol> <ul><li>有请求体</li> <li>有响应体</li> <li>多次请求多次调用</li> <li>不安全</li> <li>不缓存</li> <li>不可用于表单提交</li></ul> <ol start="9"><li>HEAD（用于获取一个文件大小 再来判断是否需要下载）</li></ol> <ul><li>没有请求头</li> <li>没有响应头</li> <li>不可用于表单提交</li> <li>安全</li> <li>冥等</li> <li>没缓存</li></ul> <h3 id="get和post有什么区别"><a href="#get和post有什么区别" class="header-anchor">#</a> GET和POST有什么区别？</h3> <ul><li>get表示获取资源，psot表示 修改资源（类似的有patch）</li> <li>get会被缓存。 post不会</li> <li>get没有请求体。post有</li> <li>get安全，post不安全</li> <li>get是冥等，psot不是</li></ul> <h3 id="put和post都是给服务器发送新增资源-有什么区别"><a href="#put和post都是给服务器发送新增资源-有什么区别" class="header-anchor">#</a> PUT和POST都是给服务器发送新增资源，有什么区别？</h3> <ul><li>PUT幂等性，post没有</li> <li>put没有响应体（返回的数据），post有</li> <li>put不能用于表单提交，post可以</li> <li>tips:put和psot本身都可以用来创建资源</li></ul> <h3 id="put和patch都是给服务器发送修改资源-有什么区别"><a href="#put和patch都是给服务器发送修改资源-有什么区别" class="header-anchor">#</a> PUT和PATCH都是给服务器发送修改资源，有什么区别？</h3> <p>PUT的用意是直接（覆盖）替换资源，Patch只是修改已知服务器资源
put 冥等，patch不是冥等</p> <h3 id="post和patch都是给服务器发送修改资源-有什么区别"><a href="#post和patch都是给服务器发送修改资源-有什么区别" class="header-anchor">#</a> POST和PATCH都是给服务器发送修改资源，有什么区别？</h3> <p>post可以用于创建资源，patch旨在对已知资源进行修改</p> <h3 id="http的请求报文是什么样的"><a href="#http的请求报文是什么样的" class="header-anchor">#</a> http的请求报⽂是什么样的？</h3> <ul><li>请求行
描述请求方法，http协议版本， URL字段</li> <li>请求头部
有一些属性，content-type，host，user-agent</li> <li>请求体（put,post用在存放要运输的数据）</li></ul> <h3 id="聊一聊http的部首有哪些"><a href="#聊一聊http的部首有哪些" class="header-anchor">#</a> 聊⼀聊HTTP的部⾸有哪些？</h3> <ol><li>通用：
实体⾸部字段（Entiy Header Fields）:针对请求报⽂和响应报⽂的实体部分使⽤⾸部</li></ol> <ul><li>Allow 资源可⽀持http请求的⽅法 ✨</li> <li>Content-Language 实体的资源语⾔</li> <li>Content-Encoding 实体的编码格式</li> <li>Content-Length 实体的⼤⼩（字节）</li> <li>Content-Type 实体媒体类型 38</li> <li>HTTP⾯试题 Content-MD5 实体报⽂的摘要 Content-Location 代替资源的yri Content-Rnages 实体主体的位置返回 Last-Modified 资源最后的修改资源 ✨ Expires 实体主体的过期资源 ✨
一般字段</li> <li>Cache-Control 控制缓存 ✨</li> <li>Connection 连接管理、逐条⾸部 ✨</li> <li>Upgrade 升级为其他协议</li> <li>via 代理服务器的相关信息</li> <li>Wraning 错误和警告通知</li> <li>Transfor-Encoding 报⽂主体的传输编码格式 ✨</li> <li>Trailer 报⽂末端的⾸部⼀览</li> <li>Pragma 报⽂指令 Date 创建报⽂的⽇期</li></ul> <ol start="2"><li>请求头</li></ol> <ul><li>Accept 客户端或者代理能够处理的媒体类型 ✨</li> <li>Accept-Encoding 优先可处理的编码格式</li> <li>Accept-Language 优先可处理的⾃然语⾔</li> <li>Accept-Charset 优先可以处理的字符集</li> <li>If-Match ⽐较实体标记（ETage） ✨</li> <li>If-None-Match ⽐较实体标记（ETage）与 If-Match相反 ✨</li> <li>If-Modified-Since ⽐较资源更新时间（Last-Modified）✨</li> <li>If-Unmodified-Since⽐较资源更新时间（Last-Modified），与 If-Modified-Since相反 ✨</li> <li>If-Rnages 资源未更新时发送实体byte的范围请求</li> <li>Range 实体的字节范围请求 ✨</li> <li>Authorization web的认证信息 ✨</li> <li>Proxy-Authorization 代理服务器要求web认证信息</li> <li>Host 请求资源所在服务器 ✨</li> <li>From ⽤户的邮箱地址</li> <li>User-Agent 客户端程序信息 ✨</li> <li>Max-Forwrads 最⼤的逐跳次数</li> <li>TE 传输编码的优先级</li> <li>Referer 请求原始放的url</li> <li>Expect 期待服务器的特定⾏为</li></ul> <ol start="3"><li>响应头</li></ol> <ul><li>Accept-Ranges 能接受的字节范围</li> <li>Age 推算资源创建经过时间</li> <li>Location 令客户端重定向的URI ✨</li> <li>vary 代理服务器的缓存信息</li> <li>ETag 能够表示资源唯⼀资源的字符串 ✨</li> <li>WWW-Authenticate 服务器要求客户端的验证信息</li> <li>Proxy-Authenticate 代理服务器要求客户端的验证信息</li> <li>Server 服务器的信息 ✨</li> <li>Retry-After 和状态码503 ⼀起使⽤的⾸部字段，表示下次请求服务器的时间</li></ul> <h3 id="聊一聊http的状态码有哪些"><a href="#聊一聊http的状态码有哪些" class="header-anchor">#</a> 聊⼀聊HTTP的状态码有哪些？</h3> <ol><li>2xx成功</li></ol> <ul><li>200请求成功</li> <li>202 Accepted 请求已接受，但是还没执⾏，不保证完成请求</li> <li>204 响应体没有数据</li></ul> <ol start="2"><li>3xx重定向</li></ol> <ul><li>301 永久性重定向</li> <li>302 found，临时性重定向，表示资源临时被分配了新的 URL ✨</li> <li>303 see other，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法定向获取资源</li> <li>304 not modified，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况</li> <li>307 temporary redirect，临时重定向，和302含义相同</li></ul> <ol start="3"><li>4xx客户端错误</li></ol> <ul><li>400 bad request，请求报⽂存在语法错误 ✨</li> <li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li> <li>403 orbidden，表示对请求资源的访问被服务器拒绝 ✨</li> <li>404 notfound,没找到资源</li></ul> <ol start="4"><li>5xx服务端错误</li></ol> <ul><li>500， 服务器在执行请求时发生错误</li> <li>501 Not Implemented 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，或者请求是服务 器不⽀持的某个⽅法</li> <li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求</li> <li>505 http version not supported 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本</li></ul> <h3 id="http的keep-alive是干什么的"><a href="#http的keep-alive是干什么的" class="header-anchor">#</a> HTTP的keep-alive是⼲什么的？</h3> <p>每次创建连接的时候都要耗费资源和时间（tcp三次握手），为了解决这样的问题，可以重用连接，不关闭连接，下次发送请求时继续使用这个连接。在请求头设置connection: keep-alive</p> <h3 id="为什么有了http为什么还要https"><a href="#为什么有了http为什么还要https" class="header-anchor">#</a> 为什么有了HTTP为什么还要HTTPS？</h3> <p>https是安全版的http，因为http协议的数据都是明⽂进⾏传输的，所以对于⼀些敏感信息的传输就很不安全，HTTPS就
是为了解决HTTP的不安全⽽⽣的。</p> <h3 id="https是如何保证安全的"><a href="#https是如何保证安全的" class="header-anchor">#</a> HTTPS是如何保证安全的？</h3> <ul><li>对称加密就是用一个密钥 来进行数据加密解密</li> <li>非对称加密就是用公钥来加密，对应的私钥解密，私钥加密，对应的公钥才能解密。</li> <li>https协议是结合非对称解密和对称加密来进行通信的。先用非对称加密来传输密钥，然后双方再用密钥进行文明的加密和密文的解密。
如果只是用对称加密，那么密钥有可能被中间人盗取，信息会泄密，那么客户端和服务端都需要传递各自的公钥，双方再结合自己的私钥、公钥还有其他数据（随机数，服务器信息），通过ECDHE算法计算通信所用的会话密钥（双方计算的密钥是一样的）。那么公钥也可能是中间人伪造的（中间人代替客户端发送公钥），那么就需要属于自己（服务器或客户端）CA的签名证书去验证公钥，但是签名证书（其中一端的通过私钥生成CSR和ca的证书和私钥生成的，就是将证书内容通过HASH算法生成一个摘要，再用私钥进行加密）的真伪性同样也需要验证，需要CA的证书和公钥去验证（用私钥解密的内容得到摘要，在进行对比验证真伪性，正确的话，用得到的摘要用公钥解密，对比服务名称，ip地址等，如果没问题，则证明公钥是正确的。），一般知名机构的CA的证书都会放在浏览器，自动完成验证，否则需要企业自己去验证。</li></ul> <p><em><strong>tips:如果使用非对称加密，每次传送数据就非常慢，经过很多繁琐的验证步骤。</strong></em></p> <h3 id="http2相对于http1-x有什么优势和特点"><a href="#http2相对于http1-x有什么优势和特点" class="header-anchor">#</a> HTTP2相对于HTTP1.x有什么优势和特点？</h3> <ul><li>二进制分层帧。
帧就是http2数据的最小单位，每一帧都有一个streamID.
二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧，二进制更容易被解析</li> <li>多路复用
同一个域，一次tcp连接可用于多个请求，可以不断地像服务端发送帧，然后服务器根据每一帧的sreamID拼接一整块数据。http1.x协议多个请求多个tcp连接，而且同一个域最多可有4个tcp连接的建立。http2相比HTTP1，能节省更多的资源和时间。</li> <li>头部压缩</li> <li>服务端推送
浏览器发一个请求，服务器可以主动向浏览器推送和这个请求相关的资源，不用浏览器发起后续请求。</li></ul> <h3 id="http的缓存的过程是怎样的"><a href="#http的缓存的过程是怎样的" class="header-anchor">#</a> HTTP的缓存的过程是怎样的？</h3> <ul><li>客户端发起资源请求</li> <li>服务器返回资源，并标记该资源是否缓存</li> <li>如果缓存，客户端就缓存</li> <li>下次客户端发起请求相同资源时，先去服务端验证资源的有效期，</li> <li>如果有效，则直接应用缓存，无效则服务器返回最新资源</li></ul> <h3 id="什么时候会触发强缓存或者协商缓存"><a href="#什么时候会触发强缓存或者协商缓存" class="header-anchor">#</a> 什么时候会触发强缓存或者协商缓存？</h3> <h4 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h4> <ul><li><h2 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h2>
Wed, 11 May 2018 07:20:00 GMT
<ul><li>介绍
它描述的是⼀个绝对时间，由服务器返回。如果修改了本地时间，会有影响。</li></ul></li> <li>cache-control
-格式：
max-age=315360000
-介绍
描述是一个相对时间。优先级比 expires高，目前主流是使用这种方式。</li> <li>还有其他值表示
<ul><li>cache-contol: no-cache.先缓存本地，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使⽤</li> <li>Cache-Control: no-store，不会产⽣任何缓存</li> <li>Cache-Control: public可以被所有⽤户缓存，包括终端和CDN等中间代理服务器</li> <li>Cache-Control: private只能被终端浏览器缓存，不允许中继缓存服务器进⾏缓存</li></ul></li></ul> <h4 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h4> <p>当cache-control或expires过期，cache-control为no-cache，就去和服务器协商，看看缓存和服务器资源版本是否一致，一致返回304，不一致就返回新的资源</p> <h3 id="服务器判断缓存是否是新鲜的方法就是依靠http的另外两组信息"><a href="#服务器判断缓存是否是新鲜的方法就是依靠http的另外两组信息" class="header-anchor">#</a> 服务器判断缓存是否是新鲜的⽅法就是依靠HTTP的另外两组信息</h3> <ul><li>last-Modify-Since/if-Modify-Since
服务端返回 last-Modify-Since的时间，当资源过期了，再发起一个请求时就会与服务器协商，根据请求中的if-Modify-Since的值（last-Modify-Since的时间）判断资源是否最新</li> <li>Etag/If-None-match
Etag存放内容摘要，当资源过期了，再发起一个请求时就会与服务器协商，根据请求中的If-None-match值判断资源是否最新。精度比last-Modify-Since/if-Modify-Since高</li></ul> <h3 id="http的整个流程-涉及tcp-ip协议"><a href="#http的整个流程-涉及tcp-ip协议" class="header-anchor">#</a> http的整个流程，涉及tcp/ip协议</h3> <h3 id="tcp粘包是怎么回事-如何处理-✨"><a href="#tcp粘包是怎么回事-如何处理-✨" class="header-anchor">#</a> TCP粘包是怎么回事，如何处理? ✨</h3> <p>发送数据包时，服务器会启用延迟发送算法，短时间内，可能会会缓冲几个数据包，然后发送的时候，可能会有一个或多个包。主要是节省网络资源的目的
解决：. 多次发送之前间隔⼀个等待时间；关闭算法；数据分包（在数据上做标记，在分开组合完整的数据），</p> <h3 id="为什么udp不会分包"><a href="#为什么udp不会分包" class="header-anchor">#</a> 为什么udp不会分包</h3> <ol><li>TCP协议是⾯向流的协议，UDP是⾯向消息的协议</li> <li>UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据</li> <li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易 进⾏区分处理了。</li></ol> <h3 id="ios7层模型"><a href="#ios7层模型" class="header-anchor">#</a> IOS7层模型</h3> <p>应用层 &gt; 表示层 &gt; 会话层 &gt; 传输层 &gt; 网络层 &gt; 链路层 &gt; 物理层</p> <h3 id="讲一下三次握手"><a href="#讲一下三次握手" class="header-anchor">#</a> 讲⼀下三次握⼿？</h3> <p>客户端 向服务器 发起 请求，申请简历连接，这是第一次握手。
服务端收到请求，同意连接，然后返回确认的信号，这是第二次握手。
客户端收到服务端回应后，确认可以建立连接，然后建立tcp连接了，这是第三次握手。</p> <h3 id="讲一下四次握手"><a href="#讲一下四次握手" class="header-anchor">#</a> 讲⼀下四次握⼿？</h3> <p>客户端想关闭连接，向服务器发起了申请（1）
服务端收到后，接受客户端关闭连接，但还准备好关闭连接。（2）
服务端准备好关闭后，告诉客户端，我可以了（3）
客户端收到服务端 回应，然后对服务器说，你关闭吧。之后服务器关闭了，客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊ CLOSED 状态。（4）</p> <h3 id="如何理解-tcp-backlog"><a href="#如何理解-tcp-backlog" class="header-anchor">#</a> 如何理解 TCP backlog？</h3> <h4 id="backlog-指的-是连接缓冲队列-缓存服务器无法立即处理的握手请求。"><a href="#backlog-指的-是连接缓冲队列-缓存服务器无法立即处理的握手请求。" class="header-anchor">#</a> backlog 指的 是连接缓冲队列，缓存服务器无法立即处理的握手请求。</h4> <ul><li>有两种情况：
<ul><li>只有一个队列，队列包含 状态为SYN RECEIVED（已接收syn包） 或 ESTABLISHED（已连接）的 连接</li> <li>有个队列，一个是syn队列，一个是accept队列，syn队列缓存SYN RECEIVED的连接，⻓度系统级别可设置，accept接受  ESTABLISHED（已连接）（等待被消费）的连接，backlog参数控制accept队列最大限制个数。一般我们的服务器是采用 第二种方案。</li></ul></li> <li>过程
<ul><li>当客户端发起请求的时候，发送syn包。</li> <li>服务器接听到（listen）,接收到了syn包，把状态为SYN RECEIVED 的连接放入SYN队列，发回SYN/ACK确认包。</li> <li>客户端收到收到SYN/ACK包后，发送ACK包，客户端状态变为ESTABLISHED（已连接，此时服务器还不是ESTABLISHED状态，如果发送数据有可能重传，好在-服务器这时限载了最大的发送数据大小），服务器接收包后，状态变为ESTABLISHED（已连接）。</li></ul></li> <li>问题
<ul><li>如果accept队列满了，服务器会强制限制 SYN 包的接收速率，会不断重复发送SYN/ACK包，客户端认为发送的ACK包丢失（正常情况，S客户端接收YN/ACK包后发送ACK包），反复重试，发送ACK包给服务器，直到banklog（accept队列有空位）减少，协议栈处理ACK包，然后把SYN队列中的连接状态改为ESTABLISHED（已连接），别移动到accept队列。否者服务器发送RST包，让请求异常。</li> <li>如果syn队列满了，如果连接处理时间过长，服务端丢弃SYN包（(⽽不是回⼀个 RST 包），以便客户端会重新发syn包，直到可以为止。</li></ul></li> <li>其他
banklog可以控制大小，什么时候扩大，什么时候扩小。</li> <li>扩小</li></ul> <ol><li>无用syn包越来越多（响应时间超多tcp超时重传时间）</li> <li>服务器性能下降</li> <li>常遭受syn flood攻击时</li></ol> <ul><li>扩大</li></ul> <ol><li>服务器性能好，请求频繁</li> <li>RRT往返时间 较长时</li></ol> <h2 id="浏览器原理"><a href="#浏览器原理" class="header-anchor">#</a> 浏览器原理</h2> <h3 id="路由"><a href="#路由" class="header-anchor">#</a> 路由</h3> <ul><li>hash
通过 hash值的改变，用hashchange去更新页面。（location.hash改变（会响应到浏览器地址）、在浏览器地址直接改变）</li> <li>history
historty.pushState/history.replaceState可以直接改变浏览器地址，但如果pushState/replaceState传入hash并不会触发hashchange事件
popState事件不会被historty.pushState/history.replaceState，只能通过浏览器的前进/后退按钮触发，或者是通过history.back()、history.go、history.forward()</li></ul> <h3 id="常⻅的浏览器内核有哪些"><a href="#常⻅的浏览器内核有哪些" class="header-anchor">#</a> 常⻅的浏览器内核有哪些?</h3> <ul><li>浏览器-渲染引擎-js引擎</li> <li>苹果浏览器（Safari）-webkit-JavaScriptCore,</li> <li>谷歌-Blink(基于webkit封装)-V8,</li> <li>火狐-Gecko-SpiderMonkey</li> <li>IE-Trident-Chakra(for JScript)</li> <li>Edge-EdgeHTML-Chakra</li> <li>Node-无-V8</li></ul> <h3 id="浏览器的主要组成部分是什么"><a href="#浏览器的主要组成部分是什么" class="header-anchor">#</a> 浏览器的主要组成部分是什么？</h3> <ul><li>用户界面</li> <li>浏览器引擎，负责传递用户界面的指令到呈现引擎</li> <li>呈现引擎，解析HTML、CSS，呈现内容。</li> <li>网络，用于处理网络请求，如HTTP请求</li> <li>用户界面后端，绘制用户界面窗口，在底层调用操作系统接口</li> <li>js解析器，解析和执行js代码</li> <li>数据储存，如cookie</li></ul> <h3 id="浏览器是如何渲染ui的"><a href="#浏览器是如何渲染ui的" class="header-anchor">#</a> 浏览器是如何渲染UI的？</h3> <ul><li>解析html元素，生成dom节点树</li> <li>解析css，生成cssom树</li> <li>结合cssdom和dom树（基于css选择符匹配dom节点），生成渲染树，渲染树没有head，meta,title元素，包括display：none的元素。</li> <li>布局（计算每个节点的渲染属性，位置，大小）</li> <li>根据渲染树的数据绘制（计算元素在屏幕所占的像素）。如果与某部分任务不影响显示内容荣，则把绘制拆分成不同的任务（层）。例如动画需要GPU硬件加速，把像个元素提升到合成层，避免绘制的发生。</li> <li>把页面和层合并（渲染结果）</li> <li>然后层现画面</li></ul> <h3 id="浏览器如何解析css选择器"><a href="#浏览器如何解析css选择器" class="header-anchor">#</a> 浏览器如何解析css选择器？</h3> <ol><li>解析HTML生成DOM树，同时下载css</li> <li>解析css，生成cssRule</li> <li>根据css选择器信息，遍历dom树，赋予相应节点的样式</li></ol> <ul><li>遍历顺序是重右到左，因为这样可以筛选掉一部分没用的元素</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.ab nav span</span> <span class="token punctuation">{</span>
  ...
<span class="token punctuation">}</span>
</code></pre></div><ul><li>先在树找到span。</li> <li>然后再往上找nav。</li> <li>然后找到nav再往上找ab。</li></ul> <h3 id="dom-tree是如何构建的"><a href="#dom-tree是如何构建的" class="header-anchor">#</a> DOM Tree是如何构建的？</h3> <ol><li>解析下载html的的⼆进制数据，通过解码器将数据转为真正的html字符串</li> <li>解析html。生成token（ast树）</li> <li>构建node，并对node添加父节点，兄弟节点等引用</li> <li>根据节点关系建立dom树</li></ol> <h3 id="浏览器重绘与重排的区别"><a href="#浏览器重绘与重排的区别" class="header-anchor">#</a> 浏览器重绘与重排的区别？</h3> <p>重排需要重新计算元素渲染属性，然后重排，要重复这个过程。
重绘，不一定会发生重排，重排一定会发生重绘</p> <h3 id="如何触发重排和重绘"><a href="#如何触发重排和重绘" class="header-anchor">#</a> 如何触发重排和重绘？</h3> <ul><li>重排（布局），改变元素大小，定位。需要重绘，再重排。</li> <li>改变颜色只会触发重绘，因为不需要重新计算渲染属性，只需要执行重绘</li> <li>添加、删除、更新DOM节点</li> <li>通过display: none隐藏⼀个DOM节点-触发重排和重绘</li> <li>通过visibility: hidden隐藏⼀个DOM节点-只触发重绘，因为没有⼏何变化</li> <li>移动或者给⻚⾯中的DOM节点添加动画</li> <li>添加⼀个样式表，调整样式属性</li> <li>⽤户⾏为，例如调整窗⼝⼤⼩，改变字号，或者滚动</li></ul> <h3 id="如何避免重绘或者重排"><a href="#如何避免重绘或者重排" class="header-anchor">#</a> 如何避免重绘或者重排？</h3> <ol><li>把样式修改，放到一个样式，然后修改样式时，替换样式名称就可以。</li> <li>提升到合成层，比如使用tranform，opacity属性。他们把元素提升到合成层，发送到GPU处理，并且缓存下来，不会引起浏览器重绘。</li></ol> <ul><li>优化合成层：
<ol><li>避免使用隐式合成层，不仅会发送数据到GPU，还会引起一次重绘</li> <li>不能压缩合成层</li> <li>will-change,告诉浏览器即将要渲染什么，让浏览器提前准备好，比如复杂的动画，就比较好，否则没必要，因为需要一定内存空间。</li></ol></li> <li>触发合成层的属性有，tranform,opacity,filter,postioned:fixed,<code>&lt;video&gt;</code>，<code>&lt;canvas&gt;</code>和<code>&lt;iframe&gt;</code>元件,3D转换：translate3d，translateZ</li></ul> <ol start="3"><li>通过DocumentFragment创建一个游离的节点，然后在这个节点上批量操作，然后插到html中</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">var</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token keyword">let</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;p&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    node<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> i<span class="token punctuation">;</span> 
    fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="3"><li></li></ol> <h3 id="前端如何实现即时通讯"><a href="#前端如何实现即时通讯" class="header-anchor">#</a> 前端如何实现即时通讯？</h3> <ul><li>短查询，浏览器隔一段时间查询
<ul><li>优点: 兼容性强，实现⾮常简单</li> <li>缺点：延迟性⾼，⾮常消耗请求资源，影响性能</li></ul></li> <li>websocket(是⼀个全新的、独⽴的协议，基于TCP协议,其作⽤就是在服务器和客户端之间建⽴实时的双向通信)
<ul><li>优点：真正意义上的实时双向通信，性能好，低延迟</li> <li>缺点：独⽴与http的协议，因此需要额外的项⽬改造，使⽤复杂度⾼，必须引⼊成熟的库，⽆法兼容低版本浏览器</li></ul></li> <li>SSE(Server-Sent Events)
<ul><li>优点：基于HTTP⽽⽣，因此不需要太多改造就能使⽤，使⽤⽅便</li> <li>缺点：基于⽂本传输效率没有websocket⾼，不是严格的双向通信，客户端向服务端发送请求⽆法复⽤之前的连 接，需要重新发出独⽴的请求</li></ul></li> <li>comet
<ul><li>comet有两种主要实现⼿段，⼀种是基于 AJAX 的⻓轮询（long-polling）⽅式，另⼀种是基于 Iframe 及 htmlfile 的流 （streaming）⽅式，通常被叫做⻓连接。</li> <li>优点：兼容性好，资源浪费较⼩</li> <li>缺点：服务器hold连接会消耗资源，返回数据顺序⽆保证，难于管理维护</li></ul></li></ul> <h3 id="什么是浏览器同源策略"><a href="#什么是浏览器同源策略" class="header-anchor">#</a> 什么是浏览器同源策略？</h3> <ul><li>协议，域名，端口一致就是同源，任何一个要素不一致，就是非同源，都会出现跨域的问题。</li> <li>浏览器中的⼤部分内容都是受同源策略限制的，但是以下三个标签可以不受限制：</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>XXX</span> <span class="token punctuation">/&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>XXX</span> <span class="token punctuation">/&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>XXX</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span> 
</code></pre></div><h3 id="如何实现跨域"><a href="#如何实现跨域" class="header-anchor">#</a> 如何实现跨域？</h3> <ul><li>jsonp</li> <li>代理转发（nigix，node服务器）</li> <li>后端允许跨域
<a href="http://taligarsiel.com/Projects/howbrowserswork1.html" target="_blank" rel="noopener noreferrer">http://taligarsiel.com/Projects/howbrowserswork1.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="算法基础"><a href="#算法基础" class="header-anchor">#</a> 算法基础</h2> <ul><li>选择排序</li> <li>插入排序</li> <li>希尔排序</li> <li>归并排序</li> <li>快速排序</li> <li>二分查找</li></ul> <h2 id="网络安全"><a href="#网络安全" class="header-anchor">#</a> 网络安全</h2> <ul><li><p>有哪些可能引起前端安全的的问题?</p> <ol><li>XSS(Cross-site-script,跨站脚本)攻击</li></ol> <ul><li>注入型
<ul><li>浏览器网址输入参数，例如127.0.0.1?from=&lt;\srcipt&gt;alert(1)&lt;/sctript&gt;，等收到响应后执行恶意代码</li> <li>插入script节点，浏览器下载解析执行脚本
类似javascript代码存储在数据库，每个访问的用户打开网页就能下载外部脚本，盗取敏感信息（cookie）</li></ul></li> <li>防御
<ol><li>csp（content secure Policy）建立安全层.控制加载文件，如，content-secure-policy:default-src self(只能加载同源资源)，image-src *(控制加载图片资源)，还能控制外部样式加载，style-src</li> <li>内容转义</li> <li>控制黑名单</li> <li>httpOnly禁止读取cookie</li> <li>增加代码阅读难度</li> <li>html转义</li></ol></li></ul> <ol start="2"><li>CSRF(跨站请求伪造)攻击
攻击者诱导受害者进⼊第三⽅⽹站，在第三⽅⽹站中，向被攻击⽹ 站发送跨站请求。利⽤受害者在被攻击⽹站已经获取的注册凭证，绕过后台的⽤户验证，达到冒充⽤户对被攻击的⽹站 执⾏某项操作的⽬的。（银行转账，在某评论区发表评论等操作等不良行为）
<ul><li>类型
<ol><li>POST类型的CSRF
获取用户凭证，自动提交表单，模拟一次用户操作</li> <li>GET类型的CSRF</li> <li>链接类型的CSRF
用户浏览一些网站，如论坛，单击了一些外部链接</li></ol></li> <li>防御
<ol><li>禁止用户跳转外部网站的操作（掘金，简书做法类似）</li> <li>后端验证请求头refer（能修改伪造，hhtps模式下不能用），但不太好用</li> <li>同源检测，sameSite(禁止cookie跨域携带)或者服务器验证 域名是否可信任（客户端带过来的带Origin字段）</li> <li>要求请求携带攻击者无法携带的Token（表达提交，页面提交，服务器验证）</li> <li>双重Cookie验证，请求头添加cookie，请求URL添加sdrfcookie参数，后端验证两个cookie是否一致。
（只要对方知道你的规则，其实，csrf攻击很难防）</li></ol></li></ul></li> <li>点击劫持（注入透明的iframe，iframe地址指向攻击者预先准备的网站，诱导用户点击隐藏的网站按钮，对要攻击的目标网站发起攻击）</li> <li>OS攻击（注入危险命令）</li> <li>HTTP劫持（篡改dns,让用户一模一样/非预期的网站）</li> <li>SQL注入
比如 后台是读取前端某个值 进行sql查询，如果输入是 1 or ,本来是查询某一条数据，结果全部数据查出来了，暴露了信息。</li> <li>DDOS攻击
SYN Flood, 利用tcp三次握手服务器接收到客户端请求连接的syn包时，后续操作需要一定的时间，不断的给服务器包发送syn包，服务器为了处理这些请求，会不断地申请内存资源，服务器会处理请求变得缓慢，严重会崩溃。
HTTP Flood
并不断发送http请求。靠谱的运行商会自动加入黑名单，防止攻击。</li></ol></li></ul> <h3 id="xss分为哪几类"><a href="#xss分为哪几类" class="header-anchor">#</a> XSS分为哪⼏类?</h3> <ul><li>注入型</li> <li>储存型</li></ul> <h3 id="如何预防xss"><a href="#如何预防xss" class="header-anchor">#</a> 如何预防XSS?</h3> <ol><li>csp（content secure Policy）建立安全层.控制加载文件，如，content-secure-policy:default-src self(只能加载同源资源)，image-src *(控制加载图片资源)，还能控制外部样式加载，style-src</li> <li>内容转义</li> <li>控制黑名单</li> <li>httpOnly禁止读取cookie</li> <li>增加代码阅读难度</li> <li>html转义</li></ol> <h3 id="针对第一个要素-我们是否能够在用户输入的过程-过滤掉用户输入的恶意代码呢"><a href="#针对第一个要素-我们是否能够在用户输入的过程-过滤掉用户输入的恶意代码呢" class="header-anchor">#</a> 针对第⼀个要素：我们是否能够在⽤户输⼊的过程，过滤掉⽤户输⼊的恶意代码呢？</h3> <p>不知内容要输出到哪里，如果输出到浏览器，浏览器还能识别转义符，如果是用于vue模板，那么不能识别，原样输出。</p> <h3 id="在用户提交时-由前端过滤输入-然后提交到后端。这样做是否可行呢"><a href="#在用户提交时-由前端过滤输入-然后提交到后端。这样做是否可行呢" class="header-anchor">#</a> 在⽤户提交时，由前端过滤输⼊，然后提交到后端。这样做是否可⾏呢？</h3> <p>不可行。因为攻击者可能会绕过前端，伪造请求直接提交恶意代码</p> <h3 id="那么-换一个过滤时机-后端在写入数据库前-对输入进行过滤-然后把-安全的-内容-返回给前端。这样是否可行呢"><a href="#那么-换一个过滤时机-后端在写入数据库前-对输入进行过滤-然后把-安全的-内容-返回给前端。这样是否可行呢" class="header-anchor">#</a> 那么，换⼀个过滤时机：后端在写⼊数据库前，对输⼊进⾏过滤，然后把“安全的”内容，返回给前端。这样是否可⾏呢？</h3> <p>不行，万一别的网站也用到这个数据，那么如果没有过滤机，那么后果不堪设想，而且换一个过滤子需要一定成本</p> <h3 id="如何应对网络劫持"><a href="#如何应对网络劫持" class="header-anchor">#</a> 如何应对⽹络劫持?</h3> <ul><li>网络劫持（强制指定跳转到非预期的网站（如果本来跳去京东，最后强制跳到淘宝）：
HTTP劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)
DNS劫持：DNS解析劫持（修改运行商DNS记录）/302跳转</li> <li>解决办法
DNS劫持由于涉嫌违法,已经被监管起来,现在很少会有DNS劫持,⽽http劫持依然⾮常盛⾏. 最有效的办法就是全站HTTPS,将HTTP加密,这使得运营商⽆法获取明⽂,就⽆法劫持你的响应内容。</li></ul> <h3 id="https一定是安全的吗"><a href="#https一定是安全的吗" class="header-anchor">#</a> HTTPS⼀定是安全的吗?</h3> <p>⾮全站HTTPS并不安全。</p> <ul><li>例子
<ul><li>一个页面是HTTP页面一个非HTTP页面，黑客有可能冒充中间人，截获了，用户的账号密码。⽤户 &lt;== HTTP ==&gt; ⿊客 &lt;== HTTPS ==&gt; 银⾏</li> <li>中间人是指一个控制着两端的信息传输，窃取私密信息的角色，但是双方不知道这个角色的存在，以为还在进行私密的会话。</li></ul></li></ul> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h2> <ul><li>webpack与grunt、gulp的不同？</li> <li>有哪些常⻅的Loader？</li> <li>有哪些常⻅的Plugin？</li> <li>Loader和Plugin的不同？</li> <li>webpack的构建流程是什么?</li> <li>是否写过Loader和Plugin？描述⼀下编写loader或plugin的思路？</li> <li>webpack的热更新是如何做到的？说明其原理？</li> <li>如何⽤webpack来优化前端性能？</li> <li>如何提⾼webpack的打包速度?</li> <li>如何提⾼webpack的构建速度？</li> <li>怎么配置单⻚应⽤？怎么配置多⻚应⽤？</li></ul> <h2 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h2> <h3 id="你对mvvm的理解"><a href="#你对mvvm的理解" class="header-anchor">#</a> 你对MVVM的理解?</h3> <p>视图层-视图模型层-数据模型，视图模型层是核心，控制着视图层和数据模型层，实现数据和视图的解耦，是开法者专注于业务开发。比如vue的设计模式，只要改变数据就可以通知更新视图</p> <h3 id="mvvm的优缺点"><a href="#mvvm的优缺点" class="header-anchor">#</a> MVVM的优缺点?</h3> <ul><li>优点</li></ul> <ol><li>数据层和视图层分离，开发者更加专注业务</li> <li>使用方便，自动更新dom</li></ol> <ul><li>缺点</li></ul> <ol><li>model层，view层出现bug，很难调试</li> <li>占用内存，消耗一定资源（闭包）</li></ol> <h3 id="你对vue生命周期的理解"><a href="#你对vue生命周期的理解" class="header-anchor">#</a> 你对Vue⽣命周期的理解？</h3> <p>beforeCreate-&gt; created -&gt;beforeUpdated-&gt; Updated -&gt; beforemounted -&gt; mounted</p> <ul><li>beforeCreate的生命周期，绑定生命周期需要的钩子函数和属性。</li> <li>created的生命周期，对数据进行劫持。</li> <li>beforeUpdated就是数据改变触发更新前执行的阶段</li> <li>Updated就是更新完毕之后执行的阶段（虚拟dom遍历、对比，深度优先）</li> <li>beforemount就是再更新前执行阶段，vue在编译html生虚拟dom，一般脚手架帮我们编译好虚拟dom，减少挂载时间</li> <li>mounted就是挂载html之后执行的钩子，通常数据更新操作的订阅是在这里同时执行</li></ul> <h3 id="异步请求适合在哪个生命周期调用"><a href="#异步请求适合在哪个生命周期调用" class="header-anchor">#</a> 异步请求适合在哪个⽣命周期调⽤？</h3> <ul><li>如果是第一次挂载vue，请求一次数据
适合在creared钩子函数，如果在beforeCreated, 还不能获取data的属性。如果放在mounted，又感觉太慢，肯定会再出发一次更新，其他生命周期 更不用说了，第一次根本不会执行，或者第一次初始化拿不到$el属性</li> <li>如果是dom变化之后请求
那么就得在updated钩子，还能获取最新的dom</li></ul> <h3 id="vue组件如何通信"><a href="#vue组件如何通信" class="header-anchor">#</a> Vue组件如何通信？</h3> <p>props，project/inject, 自定义事件，model（sync）</p> <h3 id="computed和watch有什么区别"><a href="#computed和watch有什么区别" class="header-anchor">#</a> computed和watch有什么区别?</h3> <p>computed 是在属性有变化时才执行回调函数，没变化不执行，适合于复杂计算值的场景，可以缓存计算结果，避免多次调用回调函数
watch是在属性变化时才执行回调函数，不太适合缓存计算结果</p> <h3 id="proxy与object-defineproperty的优劣对比"><a href="#proxy与object-defineproperty的优劣对比" class="header-anchor">#</a> Proxy与Object.defineProperty的优劣对⽐?</h3> <p>Proxy缺点
兼容性差，不支持IE11</p> <ul><li>Object.defineProperty优点
es5的api,兼容好</li> <li>Object.defineProperty缺点</li></ul> <ol><li>vue中，对数据的劫持，需要深度遍历遍历对象的属性，会形成一层层的闭包，占用内存，除非关闭页面</li> <li>不支持数组</li></ol> <ul><li>Proxy 优点</li></ul> <ol><li>监听对象而非属性。vue3里因为这个，执行效率和内存占用减少了一半</li> <li>支持数组的代理</li> <li>支持对象多种方法的劫持，apply、ownKeys、deleteProperty、has</li></ol> <h3 id="既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff"><a href="#既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff" class="header-anchor">#</a> 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟dom进行diff?</h3> <ul><li>浏览器dom的更新性能消耗的代价是非常昂贵的，当然浏览器执行很快，我们根本察觉不到。使用虚拟dom，是为了把组件所有的dom操作都在集中在一个节点上，然后批量更新，浏览器只需更新一次dom，如果不使用dom，那么浏览器可能会多次更新dom（浏览器也有自己的批量优化），造成不必要的性能开销。</li> <li>每个组件就有一个对应的watcher，如果粒度过高，那么可能需要创建更多的wacher实例，性能开销更大，如果里度过低，又无法准确定位变化的位置。进行虚拟domdiff实质为一种折中的方法，解决了上面的问题，大概知道要更新的地方，让后再对这个地方进行细节的对比。</li></ul> <h3 id="vue为什么没有类似于react中shouldcomponentupdate的生命周期"><a href="#vue为什么没有类似于react中shouldcomponentupdate的生命周期" class="header-anchor">#</a> Vue为什么没有类似于React中shouldComponentUpdate的⽣命周期？</h3> <p>因为react的更新，是更新整个树，通常会有不必要的diff，造成性能的开销，而vue使用数据劫持，diff粒度更精准，粒度更细，不会有无用的diff，所以vue不考虑加入shouldComponentUpdate的⽣命周期</p> <h3 id="vue中的key到底有什么用"><a href="#vue中的key到底有什么用" class="header-anchor">#</a> Vue中的key到底有什么⽤？</h3> <p>dif先会进⾏新旧节点的⾸尾交叉对⽐等四种方式,当⽆法匹配的时候会⽤新节点的 key 与旧节点进⾏⽐对,然后找出差异。
diff的时候，快速定位要diff的虚拟dom，提升diff的效率，如果没有diff，可能会出现非期望的效果，如更新一个列，如果不绑定key，那么更新可能会有问题。</p> <h3 id="你是如何理解vue的响应式系统的"><a href="#你是如何理解vue的响应式系统的" class="header-anchor">#</a> 你是如何理解Vue的响应式系统的</h3> <ul><li>任何⼀个 Vue Component 都有⼀个与之对应的 Watcher 实例。</li> <li>Vue 的 data 上的属性会被添加 getter 和 setter 属性。</li> <li>当 Vue Component render 函数被执⾏的时候, data 上会被 触碰(touch), 即被读, getter ⽅法会被调⽤, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这⼀过程被称为依赖收集)</li> <li>data 被改动时（主要是⽤户操作）, 即被写, setter ⽅法会被调⽤, 此时 Vue 会去通知所有依赖于此 data 的组件去 调⽤他们的 render 函数进⾏更新。</li></ul> <h2 id="react"><a href="#react" class="header-anchor">#</a> React</h2> <ul><li>React最新的⽣命周期是怎样的?</li> <li>React的请求应该放在哪个⽣命周期中?</li> <li>setState到底是异步还是同步?</li> <li>React组件通信如何实现?</li> <li>React有哪些优化性能是⼿段?</li> <li>React如何进⾏组件/逻辑复⽤?</li> <li>mixin、hoc、render props、react-hooks的优劣如何？</li> <li>你是如何理解fiber的?</li> <li>你对 Time Slice的理解?</li> <li>redux的⼯作流程?</li> <li>react-redux是如何⼯作的?</li> <li>redux与mobx的区别?</li> <li>redux中如何进⾏异步操作?</li> <li>redux异步中间件之间的优劣?</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/JhonLandy/webDev/edit/master/docs/sidebar/review/index.md" target="_blank" rel="noopener noreferrer">帮助小弟弟改善此页面！</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/sidebar/jest/测试用例.html" class="prev">
        测试用例
      </a></span> <span class="next"><a href="/sidebar/manager/前端管理.html">
        前端管理学习
      </a>
      →
    </span></p></div> <div class="page-commit" data-v-560d5a94><!----> <p style="display: none" data-v-560d5a94>[
  {
    &quot;type&quot;: &quot;group&quot;,
    &quot;title&quot;: &quot;糯米学习笔记&quot;,
    &quot;children&quot;: [],
    &quot;collapsable&quot;: false
  },
  {
    &quot;type&quot;: &quot;group&quot;,
    &quot;title&quot;: &quot;浏览器&quot;,
    &quot;sidebarDepth&quot;: 1,
    &quot;children&quot;: [
      {
        &quot;title&quot;: &quot;性能指标&quot;,
        &quot;frontmatter&quot;: {
          &quot;title&quot;: &quot;浏览器性能指标&quot;
        },
        &quot;regularPath&quot;: &quot;/sidebar/browers/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87.html&quot;,
        &quot;relativePath&quot;: &quot;sidebar/browers/性能指标.md&quot;,
        &quot;key&quot;: &quot;v-131ef6e8&quot;,
        &quot;path&quot;: &quot;/sidebar/browers/性能指标.html&quot;,
        &quot;headers&quot;: [
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;FP、FCP、FMP与TTI&quot;,
            &quot;slug&quot;: &quot;fp、fcp、fmp与tti&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;FP&quot;,
            &quot;slug&quot;: &quot;fp&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;FCP&quot;,
            &quot;slug&quot;: &quot;fcp&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;FMP&quot;,
            &quot;slug&quot;: &quot;fmp&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;TTI&quot;,
            &quot;slug&quot;: &quot;tti&quot;
          },
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;性能分析工具&quot;,
            &quot;slug&quot;: &quot;性能分析工具&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;谷歌开发者工具的“性能”选项进行分析：performance&quot;,
            &quot;slug&quot;: &quot;谷歌开发者工具的-性能-选项进行分析-performance&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;谷歌的Lighthouse工具（国内网络环境）：基于 node（版本≥6）&quot;,
            &quot;slug&quot;: &quot;谷歌的lighthouse工具-国内网络环境-基于-node-版本≥6&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;在线网页性能分析工具（推荐）&quot;,
            &quot;slug&quot;: &quot;在线网页性能分析工具-推荐&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;使用 Chrome 原生 lazyload 属性进行图片懒加载&quot;,
            &quot;slug&quot;: &quot;使用-chrome-原生-lazyload-属性进行图片懒加载&quot;
          }
        ],
        &quot;type&quot;: &quot;page&quot;
      }
    ],
    &quot;collapsable&quot;: true
  },
  {
    &quot;type&quot;: &quot;group&quot;,
    &quot;title&quot;: &quot;CSS&quot;,
    &quot;sidebarDepth&quot;: 1,
    &quot;children&quot;: [
      {
        &quot;title&quot;: &quot;每日一学&quot;,
        &quot;frontmatter&quot;: {
          &quot;title&quot;: &quot;每日一学&quot;
        },
        &quot;regularPath&quot;: &quot;/sidebar/css/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%AD%A6/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%AD%A6.html&quot;,
        &quot;relativePath&quot;: &quot;sidebar/css/每日一学/每日一学.md&quot;,
        &quot;key&quot;: &quot;v-4b6e7685&quot;,
        &quot;path&quot;: &quot;/sidebar/css/每日一学/每日一学.html&quot;,
        &quot;headers&quot;: [
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;样式优先级&quot;,
            &quot;slug&quot;: &quot;样式优先级&quot;
          },
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;堆叠上下文&quot;,
            &quot;slug&quot;: &quot;堆叠上下文&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;如何变成一个层叠上下文&quot;,
            &quot;slug&quot;: &quot;如何变成一个层叠上下文&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;如何改变层叠上下文中元素的在z轴的次序&quot;,
            &quot;slug&quot;: &quot;如何改变层叠上下文中元素的在z轴的次序&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;看个例子加强理解&quot;,
            &quot;slug&quot;: &quot;看个例子加强理解&quot;
          }
        ],
        &quot;type&quot;: &quot;page&quot;
      }
    ],
    &quot;collapsable&quot;: true
  },
  {
    &quot;type&quot;: &quot;group&quot;,
    &quot;title&quot;: &quot;JavaScript&quot;,
    &quot;sidebarDepth&quot;: 1,
    &quot;children&quot;: [
      {
        &quot;title&quot;: &quot;async/await-Promise语法糖&quot;,
        &quot;frontmatter&quot;: {
          &quot;title&quot;: &quot;async/await&quot;
        },
        &quot;regularPath&quot;: &quot;/sidebar/javascript/async-await.html&quot;,
        &quot;relativePath&quot;: &quot;sidebar/javascript/async-await.md&quot;,
        &quot;key&quot;: &quot;v-308199f6&quot;,
        &quot;path&quot;: &quot;/sidebar/javascript/async-await.html&quot;,
        &quot;headers&quot;: [
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;认识asny-cawait&quot;,
            &quot;slug&quot;: &quot;认识asny-cawait&quot;
          },
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;原理&quot;,
            &quot;slug&quot;: &quot;原理&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;迭代器iterator&quot;,
            &quot;slug&quot;: &quot;迭代器iterator&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;分析原理&quot;,
            &quot;slug&quot;: &quot;分析原理&quot;
          },
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;总结&quot;,
            &quot;slug&quot;: &quot;总结&quot;
          }
        ],
        &quot;type&quot;: &quot;page&quot;
      },
      {
        &quot;title&quot;: &quot;深入浅出的eventLoop&quot;,
        &quot;frontmatter&quot;: {
          &quot;title&quot;: &quot;event-loop&quot;
        },
        &quot;regularPath&quot;: &quot;/sidebar/javascript/eventLoop.html&quot;,
        &quot;relativePath&quot;: &quot;sidebar/javascript/eventLoop.md&quot;,
        &quot;key&quot;: &quot;v-571d88da&quot;,
        &quot;path&quot;: &quot;/sidebar/javascript/eventLoop.html&quot;,
        &quot;headers&quot;: [
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;深入浅出浏览器事件循环(内附练习题)&quot;,
            &quot;slug&quot;: &quot;深入浅出浏览器事件循环-内附练习题&quot;
          }
        ],
        &quot;type&quot;: &quot;page&quot;
      },
      {
        &quot;title&quot;: &quot;基础知识&quot;,
        &quot;frontmatter&quot;: {
          &quot;title&quot;: &quot;基础知识&quot;
        },
        &quot;regularPath&quot;: &quot;/sidebar/javascript/&quot;,
        &quot;relativePath&quot;: &quot;sidebar/javascript/index.md&quot;,
        &quot;key&quot;: &quot;v-29c2cfe4&quot;,
        &quot;path&quot;: &quot;/sidebar/javascript/&quot;,
        &quot;type&quot;: &quot;page&quot;
      }
    ],
    &quot;collapsable&quot;: true
  },
  {
    &quot;type&quot;: &quot;group&quot;,
    &quot;title&quot;: &quot;Git&quot;,
    &quot;sidebarDepth&quot;: 1,
    &quot;children&quot;: [
      {
        &quot;title&quot;: &quot;origin与upstream的区别&quot;,
        &quot;frontmatter&quot;: {
          &quot;title&quot;: &quot;Origin 与 Upsream 的区别&quot;
        },
        &quot;regularPath&quot;: &quot;/sidebar/git/OriginAndUpstream.html&quot;,
        &quot;relativePath&quot;: &quot;sidebar/git/OriginAndUpstream.md&quot;,
        &quot;key&quot;: &quot;v-026f6776&quot;,
        &quot;path&quot;: &quot;/sidebar/git/OriginAndUpstream.html&quot;,
        &quot;headers&quot;: [
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;Origin&quot;,
            &quot;slug&quot;: &quot;origin&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;Upsream&quot;,
            &quot;slug&quot;: &quot;upsream&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;图解&quot;,
            &quot;slug&quot;: &quot;图解&quot;
          }
        ],
        &quot;type&quot;: &quot;page&quot;
      }
    ],
    &quot;collapsable&quot;: true
  },
  {
    &quot;type&quot;: &quot;group&quot;,
    &quot;title&quot;: &quot;React&quot;,
    &quot;sidebarDepth&quot;: 2,
    &quot;children&quot;: [
      {
        &quot;title&quot;: &quot;执行流程&quot;,
        &quot;frontmatter&quot;: {
          &quot;title&quot;: &quot;React - 执行流程 （16+版本）&quot;
        },
        &quot;regularPath&quot;: &quot;/sidebar/react/process.html&quot;,
        &quot;relativePath&quot;: &quot;sidebar/react/process.md&quot;,
        &quot;key&quot;: &quot;v-28ea6045&quot;,
        &quot;path&quot;: &quot;/sidebar/react/process.html&quot;,
        &quot;type&quot;: &quot;page&quot;
      }
    ],
    &quot;collapsable&quot;: true
  },
  {
    &quot;type&quot;: &quot;group&quot;,
    &quot;title&quot;: &quot;Vue&quot;,
    &quot;sidebarDepth&quot;: 2,
    &quot;children&quot;: [
      {
        &quot;type&quot;: &quot;group&quot;,
        &quot;title&quot;: &quot;Vue2.0&quot;,
        &quot;children&quot;: [],
        &quot;collapsable&quot;: true
      },
      {
        &quot;type&quot;: &quot;group&quot;,
        &quot;title&quot;: &quot;Vue3.0&quot;,
        &quot;children&quot;: [
          {
            &quot;title&quot;: &quot;CompositionAPI小试牛刀&quot;,
            &quot;frontmatter&quot;: {
              &quot;title&quot;: &quot;Vue3.0 - CompositionAPI&quot;
            },
            &quot;regularPath&quot;: &quot;/sidebar/vue/vue3.0/CompositionAPI%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80.html&quot;,
            &quot;relativePath&quot;: &quot;sidebar/vue/vue3.0/CompositionAPI小试牛刀.md&quot;,
            &quot;key&quot;: &quot;v-8c973e70&quot;,
            &quot;path&quot;: &quot;/sidebar/vue/vue3.0/CompositionAPI小试牛刀.html&quot;,
            &quot;headers&quot;: [
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;概念&quot;,
                &quot;slug&quot;: &quot;概念&quot;
              },
              {
                &quot;level&quot;: 3,
                &quot;title&quot;: &quot;尝鲜代码&quot;,
                &quot;slug&quot;: &quot;尝鲜代码&quot;
              }
            ],
            &quot;type&quot;: &quot;page&quot;
          },
          {
            &quot;title&quot;: &quot;Vue3采坑笔记&quot;,
            &quot;frontmatter&quot;: {
              &quot;title&quot;: &quot;Vue3.0 - Vue3采坑笔记&quot;
            },
            &quot;regularPath&quot;: &quot;/sidebar/vue/vue3.0/Vue3%E9%87%87%E5%9D%91%E7%AC%94%E8%AE%B0.html&quot;,
            &quot;relativePath&quot;: &quot;sidebar/vue/vue3.0/Vue3采坑笔记.md&quot;,
            &quot;key&quot;: &quot;v-32c653f0&quot;,
            &quot;path&quot;: &quot;/sidebar/vue/vue3.0/Vue3采坑笔记.html&quot;,
            &quot;headers&quot;: [
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;虚拟dom函数&quot;,
                &quot;slug&quot;: &quot;虚拟dom函数&quot;
              },
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;函数式组件&quot;,
                &quot;slug&quot;: &quot;函数式组件&quot;
              },
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;$attrs &amp;&amp; $listeners&quot;,
                &quot;slug&quot;: &quot;attrs-listeners&quot;
              },
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;v-bind.sync&quot;,
                &quot;slug&quot;: &quot;v-bind-sync&quot;
              },
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;v-model&quot;,
                &quot;slug&quot;: &quot;v-model&quot;
              },
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;## v-models（新增）&quot;,
                &quot;slug&quot;: &quot;v-models-新增&quot;
              },
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;自定义事件@fn&quot;,
                &quot;slug&quot;: &quot;自定义事件-fn&quot;
              },
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;watch&quot;,
                &quot;slug&quot;: &quot;watch&quot;
              },
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;computed&quot;,
                &quot;slug&quot;: &quot;computed&quot;
              },
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;provide &amp;&amp; inject&quot;,
                &quot;slug&quot;: &quot;provide-inject&quot;
              },
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;v-if &amp;&amp; v-for&quot;,
                &quot;slug&quot;: &quot;v-if-v-for&quot;
              },
              {
                &quot;level&quot;: 2,
                &quot;title&quot;: &quot;render&quot;,
                &quot;slug&quot;: &quot;render&quot;
              }
            ],
            &quot;type&quot;: &quot;page&quot;
          }
        ],
        &quot;collapsable&quot;: true
      }
    ],
    &quot;collapsable&quot;: true
  },
  {
    &quot;type&quot;: &quot;group&quot;,
    &quot;title&quot;: &quot;VueRouter原理解析&quot;,
    &quot;children&quot;: [],
    &quot;collapsable&quot;: true
  },
  {
    &quot;type&quot;: &quot;group&quot;,
    &quot;title&quot;: &quot;webpack&quot;,
    &quot;sidebarDepth&quot;: 1,
    &quot;children&quot;: [
      {
        &quot;title&quot;: &quot;webpack性能优化&quot;,
        &quot;frontmatter&quot;: {
          &quot;title&quot;: &quot;Webpack性能优化&quot;
        },
        &quot;regularPath&quot;: &quot;/sidebar/webpack/performence.html&quot;,
        &quot;relativePath&quot;: &quot;sidebar/webpack/performence.md&quot;,
        &quot;key&quot;: &quot;v-4adede25&quot;,
        &quot;path&quot;: &quot;/sidebar/webpack/performence.html&quot;,
        &quot;headers&quot;: [
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;Css 的处理&quot;,
            &quot;slug&quot;: &quot;css-的处理&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;对Less、Sass 做处理&quot;,
            &quot;slug&quot;: &quot;对less、sass-做处理&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;使⽤postcss为样式⾃动补⻬浏览器前缀&quot;,
            &quot;slug&quot;: &quot;使用postcss为样式自动补⻬浏览器前缀&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;抽离css&quot;,
            &quot;slug&quot;: &quot;抽离css&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;压缩&quot;,
            &quot;slug&quot;: &quot;压缩&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;Tree Shaking&quot;,
            &quot;slug&quot;: &quot;tree-shaking&quot;
          },
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;对js的处理&quot;,
            &quot;slug&quot;: &quot;对js的处理&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;tree shaking&quot;,
            &quot;slug&quot;: &quot;tree-shaking-2&quot;
          },
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;sideEffects&quot;,
            &quot;slug&quot;: &quot;sideeffects&quot;
          },
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;对babel 的处理&quot;,
            &quot;slug&quot;: &quot;对babel-的处理&quot;
          },
          {
            &quot;level&quot;: 2,
            &quot;title&quot;: &quot;图片压缩&quot;,
            &quot;slug&quot;: &quot;图片压缩&quot;
          }
        ],
        &quot;type&quot;: &quot;page&quot;
      }
    ],
    &quot;collapsable&quot;: true
  },
  {
    &quot;type&quot;: &quot;group&quot;,
    &quot;title&quot;: &quot;jest&quot;,
    &quot;sidebarDepth&quot;: 1,
    &quot;children&quot;: [
      {
        &quot;title&quot;: &quot;测试用例&quot;,
        &quot;frontmatter&quot;: {
          &quot;title&quot;: &quot;测试用例&quot;
        },
        &quot;regularPath&quot;: &quot;/sidebar/jest/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html&quot;,
        &quot;relativePath&quot;: &quot;sidebar/jest/测试用例.md&quot;,
        &quot;key&quot;: &quot;v-979bfcb0&quot;,
        &quot;path&quot;: &quot;/sidebar/jest/测试用例.html&quot;,
        &quot;headers&quot;: [
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;背景&quot;,
            &quot;slug&quot;: &quot;背景&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;尝试篇&quot;,
            &quot;slug&quot;: &quot;尝试篇&quot;
          },
          {
            &quot;level&quot;: 3,
            &quot;title&quot;: &quot;实战篇&quot;,
            &quot;slug&quot;: &quot;实战篇&quot;
          }
        ],
        &quot;type&quot;: &quot;page&quot;
      }
    ],
    &quot;collapsable&quot;: true
  },
  {
    &quot;title&quot;: &quot;源计划&quot;,
    &quot;frontmatter&quot;: {
      &quot;title&quot;: &quot;源计划&quot;
    },
    &quot;regularPath&quot;: &quot;/sidebar/review/&quot;,
    &quot;relativePath&quot;: &quot;sidebar/review/index.md&quot;,
    &quot;key&quot;: &quot;v-7f5b804e&quot;,
    &quot;path&quot;: &quot;/sidebar/review/&quot;,
    &quot;headers&quot;: [
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;javascript&quot;,
        &quot;slug&quot;: &quot;javascript&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;基础&quot;,
        &quot;slug&quot;: &quot;基础&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;谈谈你对原型链的理解？ ✨&quot;,
        &quot;slug&quot;: &quot;谈谈你对原型链的理解-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;如何判断是否是数组？&quot;,
        &quot;slug&quot;: &quot;如何判断是否是数组&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;ES6模块与CommonJS模块有什么区别？&quot;,
        &quot;slug&quot;: &quot;es6模块与commonjs模块有什么区别&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;0.1+0.2为什么不等于0.3？&quot;,
        &quot;slug&quot;: &quot;_0-1-0-2为什么不等于0-3&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;类型转换的规则有哪些？&quot;,
        &quot;slug&quot;: &quot;类型转换的规则有哪些&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;类型转换的原理是什么？&quot;,
        &quot;slug&quot;: &quot;类型转换的原理是什么&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;js机制&quot;,
        &quot;slug&quot;: &quot;js机制&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;解释下变量提升？✨&quot;,
        &quot;slug&quot;: &quot;解释下变量提升-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;⼀段JavaScript代码是如何执⾏的？✨&quot;,
        &quot;slug&quot;: &quot;一段javascript代码是如何执行的-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;JavaScript的作⽤域链理解吗？✨&quot;,
        &quot;slug&quot;: &quot;javascript的作用域链理解吗-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;谈⼀谈你对this的了解？✨&quot;,
        &quot;slug&quot;: &quot;谈一谈你对this的了解-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;箭头函数的this指向哪⾥？✨&quot;,
        &quot;slug&quot;: &quot;箭头函数的this指向哪里-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;理解闭包吗？✨&quot;,
        &quot;slug&quot;: &quot;理解闭包吗-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;实现bind和call两个方法&quot;,
        &quot;slug&quot;: &quot;实现bind和call两个方法&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;js内存&quot;,
        &quot;slug&quot;: &quot;js内存&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;讲讲JavaScript垃圾回收是怎么做的？&quot;,
        &quot;slug&quot;: &quot;讲讲javascript垃圾回收是怎么做的&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;JavaScript的基本类型和复杂类型是储存在哪⾥的？&quot;,
        &quot;slug&quot;: &quot;javascript的基本类型和复杂类型是储存在哪里的&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;异步&quot;,
        &quot;slug&quot;: &quot;异步&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;async/await 是什么？&quot;,
        &quot;slug&quot;: &quot;async-await-是什么&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;dom&quot;,
        &quot;slug&quot;: &quot;dom&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;bom&quot;,
        &quot;slug&quot;: &quot;bom&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;css&quot;,
        &quot;slug&quot;: &quot;css&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;基础&quot;,
        &quot;slug&quot;: &quot;基础-2&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;CSS选择器的优先级是怎样的？✨&quot;,
        &quot;slug&quot;: &quot;css选择器的优先级是怎样的-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;有哪些⽅式（CSS）可以隐藏⻚⾯元素？&quot;,
        &quot;slug&quot;: &quot;有哪些方式-css-可以隐藏⻚面元素&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;em\\px\\rem区别？&quot;,
        &quot;slug&quot;: &quot;em-px-rem区别&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;块级元素⽔平居中的⽅法？&quot;,
        &quot;slug&quot;: &quot;块级元素水平居中的方法&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;块级元素⽔平垂直的⽅法？&quot;,
        &quot;slug&quot;: &quot;块级元素水平垂直的方法&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;块级盒子&quot;,
        &quot;slug&quot;: &quot;块级盒子&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;行内盒子&quot;,
        &quot;slug&quot;: &quot;行内盒子&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;CSS有⼏种定位⽅式？&quot;,
        &quot;slug&quot;: &quot;css有几种定位方式&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;如何理解层叠上下⽂？✨&quot;,
        &quot;slug&quot;: &quot;如何理解层叠上下文-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;清除浮动有哪些⽅法？&quot;,
        &quot;slug&quot;: &quot;清除浮动有哪些方法&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;你对css-sprites的理解&quot;,
        &quot;slug&quot;: &quot;你对css-sprites的理解&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;你对盒模型的理解？✨&quot;,
        &quot;slug&quot;: &quot;你对盒模型的理解-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;谈谈对BFC(Block Formatting Context)的理解？ ✨&quot;,
        &quot;slug&quot;: &quot;谈谈对bfc-block-formatting-context-的理解-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;为什么有时候⼈们⽤translate来改变位置⽽不是定位？&quot;,
        &quot;slug&quot;: &quot;为什么有时候人们用translate来改变位置而不是定位&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;伪类和伪元素的区别是什么？&quot;,
        &quot;slug&quot;: &quot;伪类和伪元素的区别是什么&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;你对flex的理解？✨&quot;,
        &quot;slug&quot;: &quot;你对flex的理解-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;关于CSS的动画与过渡问题&quot;,
        &quot;slug&quot;: &quot;关于css的动画与过渡问题&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;css3新特性&quot;,
        &quot;slug&quot;: &quot;css3新特性&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;html&quot;,
        &quot;slug&quot;: &quot;html&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;doctype(⽂档类型) 的作⽤是什么？✨&quot;,
        &quot;slug&quot;: &quot;doctype-文档类型-的作用是什么-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;这三种模式的区别是什么？(接上⼀问追问)&quot;,
        &quot;slug&quot;: &quot;这三种模式的区别是什么-接上一问追问&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;HTML、XML 和 XHTML 有什么区别？&quot;,
        &quot;slug&quot;: &quot;html、xml-和-xhtml-有什么区别&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;什么是data-属性？&quot;,
        &quot;slug&quot;: &quot;什么是data-属性&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;你对HTML语义化的理解？✨&quot;,
        &quot;slug&quot;: &quot;你对html语义化的理解-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;HTML5与HTML4的不同之处&quot;,
        &quot;slug&quot;: &quot;html5与html4的不同之处&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;有哪些常⽤的meta标签？&quot;,
        &quot;slug&quot;: &quot;有哪些常用的meta标签&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;src和href的区别？&quot;,
        &quot;slug&quot;: &quot;src和href的区别&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;知道img的srcset的作⽤是什么？（追问）&quot;,
        &quot;slug&quot;: &quot;知道img的srcset的作用是什么-追问&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;还有哪⼀个标签能起到跟srcset相似作⽤？（追问）&quot;,
        &quot;slug&quot;: &quot;还有哪一个标签能起到跟srcset相似作用-追问&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;script标签中defer和async的区别？✨&quot;,
        &quot;slug&quot;: &quot;script标签中defer和async的区别-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;有⼏种前端储存的⽅式，这些⽅式的区别是什么？✨&quot;,
        &quot;slug&quot;: &quot;有几种前端储存的方式-这些方式的区别是什么-✨&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;http&quot;,
        &quot;slug&quot;: &quot;http&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;HTTP有哪些⽅法？这些⽅法的具体作⽤是什么？&quot;,
        &quot;slug&quot;: &quot;http有哪些方法-这些方法的具体作用是什么&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;GET和POST有什么区别？&quot;,
        &quot;slug&quot;: &quot;get和post有什么区别&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;PUT和POST都是给服务器发送新增资源，有什么区别？&quot;,
        &quot;slug&quot;: &quot;put和post都是给服务器发送新增资源-有什么区别&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;PUT和PATCH都是给服务器发送修改资源，有什么区别？&quot;,
        &quot;slug&quot;: &quot;put和patch都是给服务器发送修改资源-有什么区别&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;POST和PATCH都是给服务器发送修改资源，有什么区别？&quot;,
        &quot;slug&quot;: &quot;post和patch都是给服务器发送修改资源-有什么区别&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;http的请求报⽂是什么样的？&quot;,
        &quot;slug&quot;: &quot;http的请求报文是什么样的&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;聊⼀聊HTTP的部⾸有哪些？&quot;,
        &quot;slug&quot;: &quot;聊一聊http的部首有哪些&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;聊⼀聊HTTP的状态码有哪些？&quot;,
        &quot;slug&quot;: &quot;聊一聊http的状态码有哪些&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;HTTP的keep-alive是⼲什么的？&quot;,
        &quot;slug&quot;: &quot;http的keep-alive是干什么的&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;为什么有了HTTP为什么还要HTTPS？&quot;,
        &quot;slug&quot;: &quot;为什么有了http为什么还要https&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;HTTPS是如何保证安全的？&quot;,
        &quot;slug&quot;: &quot;https是如何保证安全的&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;HTTP2相对于HTTP1.x有什么优势和特点？&quot;,
        &quot;slug&quot;: &quot;http2相对于http1-x有什么优势和特点&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;HTTP的缓存的过程是怎样的？&quot;,
        &quot;slug&quot;: &quot;http的缓存的过程是怎样的&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;什么时候会触发强缓存或者协商缓存？&quot;,
        &quot;slug&quot;: &quot;什么时候会触发强缓存或者协商缓存&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;Expires&quot;,
        &quot;slug&quot;: &quot;expires&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;服务器判断缓存是否是新鲜的⽅法就是依靠HTTP的另外两组信息&quot;,
        &quot;slug&quot;: &quot;服务器判断缓存是否是新鲜的方法就是依靠http的另外两组信息&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;http的整个流程，涉及tcp/ip协议&quot;,
        &quot;slug&quot;: &quot;http的整个流程-涉及tcp-ip协议&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;TCP粘包是怎么回事，如何处理? ✨&quot;,
        &quot;slug&quot;: &quot;tcp粘包是怎么回事-如何处理-✨&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;为什么udp不会分包&quot;,
        &quot;slug&quot;: &quot;为什么udp不会分包&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;IOS7层模型&quot;,
        &quot;slug&quot;: &quot;ios7层模型&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;讲⼀下三次握⼿？&quot;,
        &quot;slug&quot;: &quot;讲一下三次握手&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;讲⼀下四次握⼿？&quot;,
        &quot;slug&quot;: &quot;讲一下四次握手&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;如何理解 TCP backlog？&quot;,
        &quot;slug&quot;: &quot;如何理解-tcp-backlog&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;浏览器原理&quot;,
        &quot;slug&quot;: &quot;浏览器原理&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;路由&quot;,
        &quot;slug&quot;: &quot;路由&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;常⻅的浏览器内核有哪些?&quot;,
        &quot;slug&quot;: &quot;常⻅的浏览器内核有哪些&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;浏览器的主要组成部分是什么？&quot;,
        &quot;slug&quot;: &quot;浏览器的主要组成部分是什么&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;浏览器是如何渲染UI的？&quot;,
        &quot;slug&quot;: &quot;浏览器是如何渲染ui的&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;浏览器如何解析css选择器？&quot;,
        &quot;slug&quot;: &quot;浏览器如何解析css选择器&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;DOM Tree是如何构建的？&quot;,
        &quot;slug&quot;: &quot;dom-tree是如何构建的&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;浏览器重绘与重排的区别？&quot;,
        &quot;slug&quot;: &quot;浏览器重绘与重排的区别&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;如何触发重排和重绘？&quot;,
        &quot;slug&quot;: &quot;如何触发重排和重绘&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;如何避免重绘或者重排？&quot;,
        &quot;slug&quot;: &quot;如何避免重绘或者重排&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;前端如何实现即时通讯？&quot;,
        &quot;slug&quot;: &quot;前端如何实现即时通讯&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;什么是浏览器同源策略？&quot;,
        &quot;slug&quot;: &quot;什么是浏览器同源策略&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;如何实现跨域？&quot;,
        &quot;slug&quot;: &quot;如何实现跨域&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;算法基础&quot;,
        &quot;slug&quot;: &quot;算法基础&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;网络安全&quot;,
        &quot;slug&quot;: &quot;网络安全&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;XSS分为哪⼏类?&quot;,
        &quot;slug&quot;: &quot;xss分为哪几类&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;如何预防XSS?&quot;,
        &quot;slug&quot;: &quot;如何预防xss&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;针对第⼀个要素：我们是否能够在⽤户输⼊的过程，过滤掉⽤户输⼊的恶意代码呢？&quot;,
        &quot;slug&quot;: &quot;针对第一个要素-我们是否能够在用户输入的过程-过滤掉用户输入的恶意代码呢&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;在⽤户提交时，由前端过滤输⼊，然后提交到后端。这样做是否可⾏呢？&quot;,
        &quot;slug&quot;: &quot;在用户提交时-由前端过滤输入-然后提交到后端。这样做是否可行呢&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;那么，换⼀个过滤时机：后端在写⼊数据库前，对输⼊进⾏过滤，然后把“安全的”内容，返回给前端。这样是否可⾏呢？&quot;,
        &quot;slug&quot;: &quot;那么-换一个过滤时机-后端在写入数据库前-对输入进行过滤-然后把-安全的-内容-返回给前端。这样是否可行呢&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;如何应对⽹络劫持?&quot;,
        &quot;slug&quot;: &quot;如何应对网络劫持&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;HTTPS⼀定是安全的吗?&quot;,
        &quot;slug&quot;: &quot;https一定是安全的吗&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;webpack&quot;,
        &quot;slug&quot;: &quot;webpack&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;Vue&quot;,
        &quot;slug&quot;: &quot;vue&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;你对MVVM的理解?&quot;,
        &quot;slug&quot;: &quot;你对mvvm的理解&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;MVVM的优缺点?&quot;,
        &quot;slug&quot;: &quot;mvvm的优缺点&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;你对Vue⽣命周期的理解？&quot;,
        &quot;slug&quot;: &quot;你对vue生命周期的理解&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;异步请求适合在哪个⽣命周期调⽤？&quot;,
        &quot;slug&quot;: &quot;异步请求适合在哪个生命周期调用&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;Vue组件如何通信？&quot;,
        &quot;slug&quot;: &quot;vue组件如何通信&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;computed和watch有什么区别?&quot;,
        &quot;slug&quot;: &quot;computed和watch有什么区别&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;Proxy与Object.defineProperty的优劣对⽐?&quot;,
        &quot;slug&quot;: &quot;proxy与object-defineproperty的优劣对比&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟dom进行diff?&quot;,
        &quot;slug&quot;: &quot;既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;Vue为什么没有类似于React中shouldComponentUpdate的⽣命周期？&quot;,
        &quot;slug&quot;: &quot;vue为什么没有类似于react中shouldcomponentupdate的生命周期&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;Vue中的key到底有什么⽤？&quot;,
        &quot;slug&quot;: &quot;vue中的key到底有什么用&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;你是如何理解Vue的响应式系统的&quot;,
        &quot;slug&quot;: &quot;你是如何理解vue的响应式系统的&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;React&quot;,
        &quot;slug&quot;: &quot;react&quot;
      }
    ],
    &quot;type&quot;: &quot;page&quot;,
    &quot;isHidden&quot;: true
  },
  {
    &quot;frontmatter&quot;: {
      &quot;0&quot;: &quot;前&quot;,
      &quot;1&quot;: &quot;端&quot;,
      &quot;2&quot;: &quot;管&quot;,
      &quot;3&quot;: &quot;理&quot;
    },
    &quot;regularPath&quot;: &quot;/sidebar/manager/%E5%89%8D%E7%AB%AF%E7%AE%A1%E7%90%86.html&quot;,
    &quot;relativePath&quot;: &quot;sidebar/manager/前端管理.md&quot;,
    &quot;key&quot;: &quot;v-616d50ea&quot;,
    &quot;path&quot;: &quot;/sidebar/manager/前端管理.html&quot;,
    &quot;headers&quot;: [
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;核心&quot;,
        &quot;slug&quot;: &quot;核心&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;前端基建&quot;,
        &quot;slug&quot;: &quot;前端基建&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;框架(技术栈)&quot;,
        &quot;slug&quot;: &quot;框架-技术栈&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;自动化&quot;,
        &quot;slug&quot;: &quot;自动化&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;接口规范、定义&quot;,
        &quot;slug&quot;: &quot;接口规范、定义&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;前端监控&quot;,
        &quot;slug&quot;: &quot;前端监控&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;前端开发规范&quot;,
        &quot;slug&quot;: &quot;前端开发规范&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;质量把控&quot;,
        &quot;slug&quot;: &quot;质量把控&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;团队成长&quot;,
        &quot;slug&quot;: &quot;团队成长&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;技术能力&quot;,
        &quot;slug&quot;: &quot;技术能力&quot;
      },
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;软技能&quot;,
        &quot;slug&quot;: &quot;软技能&quot;
      },
      {
        &quot;level&quot;: 2,
        &quot;title&quot;: &quot;影响力&quot;,
        &quot;slug&quot;: &quot;影响力&quot;
      }
    ],
    &quot;type&quot;: &quot;page&quot;,
    &quot;title&quot;: &quot;前端管理学习&quot;
  },
  {
    &quot;title&quot;: &quot;好文收集&quot;,
    &quot;frontmatter&quot;: {
      &quot;title&quot;: &quot;好文收集&quot;
    },
    &quot;regularPath&quot;: &quot;/sidebar/article/%E5%A5%BD%E6%96%87%E6%94%B6%E9%9B%86.html&quot;,
    &quot;relativePath&quot;: &quot;sidebar/article/好文收集.md&quot;,
    &quot;key&quot;: &quot;v-2cdf7cea&quot;,
    &quot;path&quot;: &quot;/sidebar/article/好文收集.html&quot;,
    &quot;headers&quot;: [
      {
        &quot;level&quot;: 3,
        &quot;title&quot;: &quot;JavaScript好文&quot;,
        &quot;slug&quot;: &quot;javascript好文&quot;
      }
    ],
    &quot;type&quot;: &quot;page&quot;
  }
]</p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/runtime.60910846.js" defer></script><script src="/assets/js/5.dc5d0932.js" defer></script><script src="/assets/js/6.194557f9.js" defer></script><script src="/assets/js/54.3e9b0ec2.js" defer></script><script src="/assets/js/8.d3f9f724.js" defer></script><script src="/assets/js/chunk-elementUI.e4c6f4b0.js" defer></script><script src="/assets/js/chunk-libs.bd30ccf7.js" defer></script><script src="/assets/js/app.d85d545c.js" defer></script>
  </body>
</html>
